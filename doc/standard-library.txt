### `std.debug`

`std.debug.print(...)`

	* Prints all arguments to the standard error stream, separated by
	  spaces. A line break is appended to terminate the line.

	* Returns `true` if the operation succeeds; otherwise `null`.

`std.debug.dump(value, [indent])`

	* Prints the value to the standard error stream with detailed
	  information. `indent` specifies the number of spaces to use as
	  a single level of indent. Its value is clamped between `0` and
	  `10` inclusively. If it is set to `0`, no line break is
	  inserted and output lines are not indented. It has a default
	  value of `2`.

	* Returns `true` if the operation succeeds; otherwise `null`.

### `std.chrono`

`std.chrono.utc_now()`

	* Retrieves the wall clock time in UTC.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an `integer`.

`std.chrono.local_now()`

	* Retrieves the wall clock time in the local time zone.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an `integer`.

`std.chrono.hires_now()`

	* Retrieves a time point from a high resolution clock. The clock
	  goes monotonically and cannot be adjusted, being suitable for
	  time measurement. This function provides accuracy and might be
	  quite heavyweight.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as a `real`.

`std.chrono.steady_now()`

	* Retrieves a time point from a steady clock. The clock goes
	  monotonically and cannot be adjusted, being suitable for time
	  measurement. This function is supposed to be fast and might
	  have poor accuracy.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as an `integer`.

`std.chrono.local_from_utc(time_utc)`

	* Converts a UTC time point to a local one. `time_utc` shall be
	  the number of milliseconds since the Unix epoch.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an `integer`.

`std.chrono.utc_from_local(time_local)`

	* Converts a local time point to a UTC one. `time_local` shall
	  be the number of milliseconds since `1970-01-01 00:00:00` in
	  the local time zone.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an `integer`.

`std.chrono.datetime_format(time_point, [with_ms])`

	* Converts `time_point`, which represents the number of
	  milliseconds since `1970-01-01 00:00:00`, to an ASCII string in
	  the aforementioned format, according to the ISO 8601 standard.
	  If `with_ms` is set to `true`, the string will have a 3-digit
	  fractional part. By default, no fractional part is added.

	* Returns a `string` representing the time point.

`std.chrono.datetime_min([with_ms])`

	* Gets the special string that denotes the negative infinity time
	  point. Calling this function has the same effect as calling
	  `datetime_format(-0x8000000000000000, with_ms)`.

	* Returns `'1601-01-01 00:00:00'` or `'1601-01-01 00:00:00.000'`
	  according to `with_ms`.

`std.chrono.datetime_max([with_ms])`

	* Gets the special string that denotes the positive infinity time
	  point. Calling this function has the same effect as calling
	  `datetime_format(0x7FFFFFFFFFFFFFFF, with_ms)`.

	* Returns `'9999-01-01 00:00:00'` or `'9999-01-01 00:00:00.000'`
	  according to `with_ms`.

`std.chrono.datetime_parse(time_str)`

	* Parses `time_str`, which is an ASCII string representing a time
	  point in the format `1970-01-01 00:00:00.000`, according to the
	  ISO 8601 standard; the subsecond part is optional and may have
	  fewer or more digits. There shall be no leading or trailing
	  spaces.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  if the time string has been parsed successfully; otherwise
	  `null`.

### `std.string`

`std.string.compare(text1, text2, [length])`

	* Performs lexicographical comparison on two byte `string`s. If
	  `length` is set to an `integer`, no more than this number of
	  bytes are compared. This function behaves like the `strncmp()`
	  function in C, except that null characters do not terminate
	  strings.

	* Returns a positive `integer` if `text1` compares greater than
	  `text2`, a negative `integer` if `text1` compares less than
	  `text2`, or zero if `text1` compares equal to `text2`.

`std.string.starts_with(text, prefix)`

	* Checks whether `prefix` is a prefix of `text`. The empty
	  `string` is considered to be a prefix of any string.

	* Returns `true` if `prefix` is a prefix of `text`; otherwise
	  `false`.

`std.string.ends_with(text, suffix)`

	* Checks whether `suffix` is a suffix of `text`. The empty
	  `string` is considered to be a suffix of any string.

	* Returns `true` if `suffix` is a suffix of `text`; otherwise
	  `false`.

`std.string.substr(text, from, [length])`

	* Copies a subrange of `text` to create a new byte string. Bytes
	  are copied from `from` if it is non-negative, and from
	  `lengthof(text) + from` otherwise. If `length` is set to an
	  `integer`, no more than this number of bytes will be copied. If
	  it is absent, all bytes from `from` to the end of `text` will
	  be copied. If `from` is outside `text`, an empty `string` is
	  returned.

	* Returns the specified substring of `text`.

`std.string.replace_substr(text, from, replacement)`

	* Replaces all bytes from `from` to the end of `text` with
	  `replacement` and returns the new byte string. If `from` is
	  negative, it specifies an offset from the end of `text`. This
	  function returns a new `string` without modifying `text`.

	* Returns a `string` with the subrange replaced.

`std.string.replace_substr(text, from, [length], replacement)`

	* Replaces all bytes from `from` to the end of `text` with
	  `replacement` and returns the new byte string. If `from` is
	  negative, it specifies an offset from the end of `text`. If
	  `length` is set to an `integer`, no more than this number of
	  bytes will be copied. If it is absent, this function is
	  equivalent to `replace_substr(text, from, replacement)`. This
	  function returns a new `string` without modifying `text`.

	* Returns a `string` with the subrange replaced.

`std.string.find(text, pattern)`

`std.string.find(text, [from], pattern)`

`std.string.find(text, [from], [length], pattern)`

`std.string.rfind(text, pattern)`

`std.string.rfind(text, [from], pattern)`

`std.string.rfind(text, [from], [length], pattern)`

`std.string.find_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, [from], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `substr(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, [from], [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `substr(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, [from], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the union of the subrange that would
	  be returned by `substr(text, from, 1)` and all bytes preceding
	  it.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, [from], [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `substr(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, [from], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `substr(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, [from], [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `substr(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, [from], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the union of the subrange that
	  would be returned by `substr(text, from, 1)` and all bytes
	  preceding it.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, [from], [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `substr(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.reverse(text)`

	* Reverses a byte `string`. This function returns a new `string`
	  without modifying `text`.

	* Returns the reversed `string`.

`std.string.trim(text, [reject])`

	* Removes the longest prefix and suffix consisting solely bytes
	  from `reject`. If `reject` is empty, no byte is removed. If
	  `reject` is not specified, spaces and tabs are removed. This
	  function returns a new `string` without modifying `text`.

	* Returns the trimmed `string`.

`std.string.trim_left(text, [reject])`

	* Removes the longest prefix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new `string` without modifying `text`.

	* Returns the trimmed `string`.

`std.string.trim_right(text, [reject])`

	* Removes the longest suffix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new `string` without modifying `text`.

	* Returns the trimmed string.

`std.string.to_upper(text)`

	* Converts all lowercase English letters in `text` to their
	  uppercase counterparts. This function returns a new `string`
	  without modifying `text`.

	* Returns a new `string` after the conversion.

`std.string.to_lower(text)`

	* Converts all uppercase English letters in `text` to their
	  lowercase counterparts. This function returns a new `string`
	  without modifying `text`.

	* Returns a new `string` after the conversion.

`std.string.explode(text, [delim], [limit])`

	* Breaks `text` down into segments, separated by `delim`. If
	  `delim` is `null` or an empty `string`, every byte becomes a
	  segment. If `limit` is set to a positive `integer`, there will
	  be no more segments than this number; the last segment will
	  contain all the remaining bytes of the `text`.

	* Returns an `array` containing the broken-down segments. If
	  `text` is empty, an empty `array` is returned.

	* Throws an exception if `limit` is zero or negative.

`std.string.implode(segments, [delim])`

	* Concatenates elements of an array, `segments`, to create a new
	  `string`. All segments shall be `string`s. If `delim` is
	  specified, it is inserted between adjacent segments.

	* Returns a `string` containing all segments. If `segments` is
	  empty, an empty `string` is returned.

`std.string.hex_encode(text, [delim], [uppercase])`

	* Encodes all bytes in `text` as 2-digit hexadecimal numbers and
	  concatenates them. If `delim` is specified, it is inserted
	  between adjacent bytes. If `uppercase` is set to `true`,
	  hexadecimal digits above `9` are encoded as `ABCDEF`; otherwise
	  they are encoded as `abcdef`.

	* Returns the encoded `string`. If `text` is empty, an empty
	  `string` is returned.

`std.string.hex_decode(hstr)`

	* Decodes all hexadecimal digits from `hstr` and converts them to
	  bytes. Whitespaces are ignored. Characters that are neither
	  hexadecimal digits nor whitespaces will cause parse errors.

	* Returns a `string` containing decoded bytes. If `hstr` is empty
	  or consists only whitespaces, an empty `string` is returned. In
	  the case of parse errors, `null` is returned.

`std.string.translate(text, inputs, [outputs])`

	* Performs bytewise translation on the given string. For every
	  byte in `text` that is also found in `inputs`, if there is a
	  corresponding replacement byte in `outputs` with the same
	  subscript, it is replaced with the latter; if no replacement
	  exists, because `outputs` is shorter than `inputs` or is null,
	  it is deleted. If `outputs` is longer than `inputs`, excess
	  bytes are ignored. Bytes that do not exist in `inputs` are left
	  intact. This function returns a new `string` without modifying
	  `text`.

	* Returns the translated `string`.

`std.string.utf8_encode(code_points, [permissive])`

	* Encodes code points from `code_points` into an UTF-8 `string`.
	  Code points shall be `integer`s. When an invalid code point is
	  encountered, if `permissive` is set to `true`, it is replaced
	  with the replacement character `"\uFFFD"` and consequently
	  encoded as `"\xEF\xBF\xBD"`; otherwise this function fails.

	* Returns the encoded `string` on success; otherwise `null`.

`std.string.utf8_decode(text, [permissive])`

	* Decodes `text`, which is expected to be a `string` containing
	  UTF-8 code units, into an `array` of code points, represented
	  as `integer`s. When an invalid code sequence is encountered, if
	  `permissive` is set to `true`, all code units of it are
	  re-interpreted as isolated bytes according to ISO/IEC 8859-1;
	  otherwise this function fails.

	* Returns an `array` containing decoded code points; otherwise
	  `null`.

`std.string.pack_8(ints)`

	* Packs a series of 8-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are truncated to 8
	  bits then copied into a `string`.

	* Returns the packed `string`.

`std.string.unpack_8(text)`

	* Unpacks 8-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 8-bit integers, all of
	  which are sign-extended to 64 bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

`std.string.pack_16be(ints)`

	* Packs a series of 16-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are truncated to 16
	  bits then copied into a `string` in the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_16be(text)`

	* Unpacks 16-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_16le(ints)`

	* Packs a series of 16-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are truncated to 16
	  bits then copied into a `string` in the little-endian byte
	  order.

	* Returns the packed `string`.

`std.string.unpack_16le(text)`

	* Unpacks 16-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_32be(ints)`

	* Packs a series of 32-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are truncated to 32
	  bits then copied into a `string` in the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_32be(text)`

	* Unpacks 32-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_32le(ints)`

	* Packs a series of 32-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are truncated to 32
	  bits then copied into a `string` in the little-endian byte
	  order.

	* Returns the packed `string`.

`std.string.unpack_32le(text)`

	* Unpacks 32-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_64be(ints)`

	* Packs a series of 64-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are copied into a
	  `string` in the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_64be(text)`

	* Unpacks 64-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  big-endian byte order, all of which are copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.string.pack_64le(ints)`

	* Packs a series of 64-bit integers into a `string`. `ints` shall
	  be an `array` of `integer`s, all of which are copied into a
	  `string` in the little-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_64le(text)`

	* Unpacks 64-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  little-endian byte order, all of which are copied into an
	  `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.
