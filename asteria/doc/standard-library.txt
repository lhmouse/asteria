### `std.version`

`std.version.major`

	* Denotes the major version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

`std.version.minor`

	* Denotes the minor version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

### `std.gc`

`std.gc.tracked_count(generation)`

	* Gets the number of variables that are being tracked by the
	  the collector for `generation`. Valid values for `generation`
	  are `0`, `1` and `2`. This value is only informative.

	* Returns the number of variables being tracked. If `generation`
	  is not valid, `null` is returned.

`std.gc.get_threshold(generation)`

	* Gets the threshold of the collector for `generation`. Valid
	  values for `generation` are `0`, `1` and `2`.

	* Returns the threshold. If `generation` is not valid, `null` is
	  returned.

`std.gc.set_threshold(generation, threshold)`

	* Sets the threshold of the collector for `generation` to
	  `threshold`. Valid values for `generation` are `0`, `1` and
	  `2`. Valid values for `threshould` range from `0` to an
	  unspecified positive `integer`; overlarge values are capped
	  silently without failure. A larger `threshold` makes garbage
	  collection run less often but slower. Setting `threshold` to
	  `0` ensures all unreachable variables be collected immediately.

	* Returns the threshold before the call. If `generation` is not
	  valid, `null` is returned.

`std.gc.collect([generation_limit])`

	* Performs garbage collection on all generations including and
	  up to `generation_limit`. If it is absent, all generations are
	  collected.

	* Returns the number of variables that have been collected in
	  total.

### `std.debug`

`std.debug.print(...)`

	* Prints all arguments to the standard error stream. A line break
	  is appended to terminate the line.

	* Returns `true` if the operation succeeds, or `null` otherwise.

`std.debug.dump(value, [indent])`

	* Prints the value to the standard error stream with detailed
	  information. `indent` specifies the number of spaces to use as
	  a single level of indent. Its value is clamped between `0` and
	  `10` inclusively. If it is set to `0`, no line break is
	  inserted and output lines are not indented. It has a default
	  value of `2`.

	* Returns `true` if the operation succeeds, or `null` otherwise.

### `std.chrono`

`std.chrono.utc_now()`

	* Retrieves the wall clock time in UTC.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an `integer`.

`std.chrono.local_now()`

	* Retrieves the wall clock time in the local time zone.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an `integer`.

`std.chrono.hires_now()`

	* Retrieves a time point from a high resolution clock. The clock
	  goes monotonically and cannot be adjusted, being suitable for
	  time measurement. This function provides accuracy and might be
	  quite heavyweight.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as a `real`.

`std.chrono.steady_now()`

	* Retrieves a time point from a steady clock. The clock goes
	  monotonically and cannot be adjusted, being suitable for time
	  measurement. This function is supposed to be fast and might
	  have poor accuracy.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as an `integer`.

`std.chrono.local_from_utc(time_utc)`

	* Converts a UTC time point to a local one. `time_utc` shall be
	  the number of milliseconds since the Unix epoch.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an `integer`.

`std.chrono.utc_from_local(time_local)`

	* Converts a local time point to a UTC one. `time_local` shall
	  be the number of milliseconds since `1970-01-01 00:00:00` in
	  the local time zone.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an `integer`.

`std.chrono.utc_format(time_point, [with_ms])`

	* Converts `time_point`, which represents the number of
	  milliseconds since `1970-01-01 00:00:00`, to an ASCII string in
	  the aforementioned format, according to the ISO 8601 standard.
	  If `with_ms` is set to `true`, the string will have a 3-digit
	  fractional part. By default, no fractional part is added.

	* Returns a `string` representing the time point.

`std.chrono.utc_parse(time_str)`

	* Parses `time_str`, which is an ASCII string representing a time
	  point in the format `1970-01-01 00:00:00.000`, according to the
	  ISO 8601 standard; the subsecond part is optional and may have
	  fewer or more digits. There shall be no leading or trailing
	  spaces.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  if the time string has been parsed successfully, or `null`
	  otherwise.

### `std.string`

`std.string.slice(text, from, [length])`

	* Copies a subrange of `text` to create a new byte string. Bytes
	  are copied from `from` if it is non-negative, or from
	  `lengthof(text) + from` otherwise. If `length` is set to an
	  `integer`, no more than this number of bytes will be copied. If
	  it is absent, all bytes from `from` to the end of `text` will
	  be copied. If `from` is outside `text`, an empty `string` is
	  returned.

	* Returns the specified substring of `text`.

`std.string.replace_slice(text, from, replacement)`

	* Replaces all bytes from `from` to the end of `text` with
	  `replacement` and returns the new byte string. If `from` is
	  negative, it specifies an offset from the end of `text`. This
	  function returns a new `string` without modifying `text`.

	* Returns a `string` with the subrange replaced.

`std.string.replace_slice(text, from, [length], replacement)`

	* Replaces a subrange of `text` with `replacement` to create a
	  new byte string. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `text`. `length` specifies the maximum number of bytes
	  to replace. If it is set to `null`, this function is equivalent
	  to `replace_slice(text, from, replacement)`. This function
	  returns a new `string` without modifying `text`.

	* Returns a `string` with the subrange replaced.

`std.string.compare(text1, text2, [length])`

	* Performs lexicographical comparison on two byte strings. If
	  `length` is set to an `integer`, no more than this number of
	  bytes are compared. This function behaves like the `strncmp()`
	  function in C, except that null characters do not terminate
	  strings.

	* Returns a positive `integer` if `text1` compares greater than
	  `text2`, a negative `integer` if `text1` compares less than
	  `text2`, or zero if `text1` compares equal to `text2`.

`std.string.starts_with(text, prefix)`

	* Checks whether `prefix` is a prefix of `text`. The empty
	  `string` is considered to be a prefix of any string.

	* Returns `true` if `prefix` is a prefix of `text`, or `false`
	  otherwise.

`std.string.ends_with(text, suffix)`

	* Checks whether `suffix` is a suffix of `text`. The empty
	  `string` is considered to be a suffix of any string.

	* Returns `true` if `suffix` is a suffix of `text`, or `false`
	  otherwise.

`std.string.find(text, pattern)`

	* Searches `text` for the first occurrence of `pattern`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find(text, from, pattern)`

	* Searches `text` for the first occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find(text, from, [length], pattern)`

	* Searches `text` for the first occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, pattern)`

	* Searches `text` for the last occurrence of `pattern`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, from, pattern)`

	* Searches `text` for the last occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, from, [length], pattern)`

	* Searches `text` for the last occurrence of `pattern`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find_and_replace(text, pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. This function returns a new `string` without
	  modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_and_replace(text, from, pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. The search operation is performed on the same
	  subrange that would be returned by `slice(text, from)`. This
	  function returns a new `string` without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_and_replace(text, from, [length], pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. The search operation is performed on the same
	  subrange that would be returned by `slice(text, from, length)`.
	  This function returns a new `string` without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, from, accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, from, [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, from, accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, from, [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, from, reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, from, [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, from, reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, from, [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.reverse(text)`

	* Reverses a byte string. This function returns a new `string`
	  without modifying `text`.

	* Returns the reversed `string`.

`std.string.trim(text, [reject])`

	* Removes the longest prefix and suffix consisting solely bytes
	  from `reject`. If `reject` is empty, no byte is removed. If
	  `reject` is not specified, spaces and tabs are removed. This
	  function returns a new `string` without modifying `text`.

	* Returns the trimmed `string`.

`std.string.ltrim(text, [reject])`

	* Removes the longest prefix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new `string` without modifying `text`.

	* Returns the trimmed `string`.

`std.string.rtrim(text, [reject])`

	* Removes the longest suffix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new `string` without modifying `text`.

	* Returns the trimmed string.

`std.string.lpad(text, length, [padding])`

	* Prepends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  `string` consisting of a space. This function returns a new
	  `string` without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.rpad(text, length, [padding])`

	* Appends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  `string` consisting of a space. This function returns a new
	  `string` without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.to_upper(text)`

	* Converts all lowercase English letters in `text` to their
	  uppercase counterparts. This function returns a new `string`
	  without modifying `text`.

	* Returns a new `string` after the conversion.

`std.string.to_lower(text)`

	* Converts all uppercase English letters in `text` to their
	  lowercase counterparts. This function returns a new `string`
	  without modifying `text`.

	* Returns a new `string` after the conversion.

`std.string.explode(text, [delim], [limit])`

	* Breaks `text` down into segments, separated by `delim`. If
	  `delim` is `null` or an empty `string`, every byte becomes a
	  segment. If `limit` is set to a positive `integer`, there will
	  be no more segments than this number; the last segment will
	  contain all the remaining bytes of the `text`.

	* Returns an `array` containing the broken-down segments. If
	  `text` is empty, an empty `array` is returned.

	* Throws an exception if `limit` is zero or negative.

`std.string.implode(segments, [delim])`

	* Concatenates elements of an array, `segments`, to create a new
	  `string`. All segments shall be `string`s. If `delim` is
	  specified, it is inserted between adjacent segments.

	* Returns a `string` containing all segments. If `segments` is
	  empty, an empty `string` is returned.

`std.string.hex_encode(data, [uppercase], [delim])`

	* Encodes all bytes in `data` as 2-digit hexadecimal numbers and
	  concatenates them. If `uppercase` is set to `true`, hexadecimal
	  digits above `9` are encoded as `ABCDEF`; otherwise they are
	  encoded as `abcdef`. If `delim` is specified, it is inserted
	  between adjacent bytes.

	* Returns the encoded `string`. If `data` is empty, an empty
	  `string` is returned.

`std.string.hex_decode(text)`

	* Decodes all hexadecimal digits from `text` and converts them to
	  bytes. Whitespaces can be used to delimit bytes; they shall not
	  occur between digits in the same byte. Consequently, the total
	  number of non-whitespace characters must be a multiple of two.
	  Invalid characters cause parse errors.

	* Returns a `string` containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty `string` is returned.
	  In the case of parse errors, `null` is returned.

`std.string.base32_encode(data, [uppercase])`

	* Encodes all bytes in `data` according to the base32 encoding
	  specified by IETF RFC 4648. If `uppercase` is set to `true`,
	  uppercase letters are used to represent values through `0` to
	  `25`; otherwise, lowercase letters are used. The length of
	  encoded data is always a multiple of 8; padding characters
	  are mandatory.

	* Returns the encoded `string`.

`std.string.base32_decode(text)`

	* Decodes data encoded in base32, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  eight. Invalid characters cause parse errors.

	* Returns a `string` containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty `string` is returned.
	  In the case of parse errors, `null` is returned.

`std.string.base64_encode(data)`

	* Encodes all bytes in `data` according to the base64 encoding
	  specified by IETF RFC 4648. The length of encoded data is
	  always a multiple of 4; padding characters are mandatory.

	* Returns the encoded `string`.

`std.string.base64_decode(text)`

	* Decodes data encoded in base64, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  four. Invalid characters cause parse errors.

	* Returns a `string` containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty `string` is returned.
	  In the case of parse errors, `null` is returned.

`std.string.translate(text, inputs, [outputs])`

	* Performs bytewise translation on the given string. For every
	  byte in `text` that is also found in `inputs`, if there is a
	  corresponding replacement byte in `outputs` with the same
	  subscript, it is replaced with the latter; if no replacement
	  exists, because `outputs` is shorter than `inputs` or is null,
	  it is deleted. If `outputs` is longer than `inputs`, excess
	  bytes are ignored. Bytes that do not exist in `inputs` are left
	  intact. This function returns a new `string` without modifying
	  `text`.

	* Returns the translated `string`.

`std.string.utf8_encode(code_points, [permissive])`

	* Encodes code points from `code_points` into an UTF-8 `string`.
	  `code_points` can be either an `integer` or an `array` of
	  `integer`s. When an invalid code point is encountered, if
	  `permissive` is set to `true`, it is replaced with the
	  replacement character `"\uFFFD"` and consequently encoded as
	  `"\xEF\xBF\xBD"`; otherwise this function fails.

	* Returns the encoded `string` on success, or `null` otherwise.

`std.string.utf8_decode(text, [permissive])`

	* Decodes `text`, which is expected to be a `string` containing
	  UTF-8 code units, into an `array` of code points, represented
	  as `integer`s. When an invalid code sequence is encountered, if
	  `permissive` is set to `true`, all code units of it are
	  re-interpreted as isolated bytes according to ISO/IEC 8859-1;
	  otherwise this function fails.

	* Returns an `array` containing decoded code points, or `null`
	  otherwise.

`std.string.pack8(values)`

	* Packs a series of 8-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integer`s, all of
	  which are truncated to 8 bits then copied into a `string`.

	* Returns the packed `string`.

`std.string.unpack8(text)`

	* Unpacks 8-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 8-bit integers, all of
	  which are sign-extended to 64 bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

`std.string.pack_16be(values)`

	* Packs a series of 16-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are truncated to 16 bits then copied into a `string` in
	  the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_16be(text)`

	* Unpacks 16-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_16le(values)`

	* Packs a series of 16-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are truncated to 16 bits then copied into a `string` in
	  the little-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_16le(text)`

	* Unpacks 16-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_32be(values)`

	* Packs a series of 32-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are truncated to 32 bits then copied into a `string` in
	  the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_32be(text)`

	* Unpacks 32-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_32le(values)`

	* Packs a series of 32-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are truncated to 32 bits then copied into a `string` in
	  the little-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_32le(text)`

	* Unpacks 32-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_64be(values)`

	* Packs a series of 64-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are copied into a `string` in the big-endian byte order.

	* Returns the packed `string`.

`std.string.unpack_64be(text)`

	* Unpacks 64-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  big-endian byte order, all of which are copied into an `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.string.pack_64le(values)`

	* Packs a series of 64-bit integers into a `string`. `values` can
	  be either an `integer` or an `array` of `integers`, all of
	  which are copied into a `string` in the little-endian byte
	  order.

	* Returns the packed `string`.

`std.string.unpack_64le(text)`

	* Unpacks 64-bit integers from a `string`. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  little-endian byte order, all of which are copied into an
	  `array`.

	* Returns an `array` containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

### `std.array`

`std.array.slice(data, from, [length])`

	* Copies a subrange of `data` to create a new `array`. Elements
	  are copied from `from` if it is non-negative, or from
	  `lengthof(data) + from` otherwise. If `length` is set to an
	  `integer`, no more than this number of elements will be copied.
	  If it is absent, all elements from `from` to the end of `data`
	  will be copied. If `from` is outside `data`, an empty `array`
	  is returned.

	* Returns the specified subarray of `data`.

`std.array.replace_slice(data, from, replacement)`

	* Replaces all elements from `from` to the end of `data` with
	  `replacement` and returns the new `array`. If `from` is
	  negative, it specifies an offset from the end of `data`. This
	  function returns a new `array` without modifying `data`.

	* Returns a `array` with the subrange replaced.

`std.array.replace_slice(data, from, [length], replacement)`

	* Replaces a subrange of `data` with `replacement` to create a
	  new `array`. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `data`. `length` specifies the maximum number of
	  elements to replace. If it is set to `null`, this function is
	  equivalent to `replace_slice(data, from, replacement)`. This
	  function returns a new `array` without modifying `data`.

	* Returns a `array` with the subrange replaced.

`std.array.find(data, target)`

	* Searches `data` for the first occurrence of `target`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find(data, from, target)`

	* Searches `data` for the first occurrence of `target`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(data, from)`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find(data, from, [length], target)`

	* Searches `data` for the first occurrence of `target`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(data, from, length)`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind(data, target)`

	* Searches `data` for the last occurrence of `target`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind(data, from, target)`

	* Searches `data` for the last occurrence of `target`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(data, from)`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind(data, from, [length], target)`

	* Searches `data` for the last occurrence of `target`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(data, from, length)`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find_if(data, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.find_if(data, from, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.find_if(data, from, [length], predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.find_if_not(data, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.find_if_not(data, from, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.find_if_not(data, from, [length], predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if(data, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if(data, from, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if(data, from, [length], predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if_not(data, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if_not(data, from, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.rfind_if_not(data, from, [length], predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

`std.array.is_sorted(data, [comparator])`

	* Checks whether `data` is sorted. That is, there is no pair of
	  adjacent elements in `data` such that the first one is greater
	  than or unordered with the second one. Elements are compared
	  using `comparator`, which shall be a binary `function` that
	  returns a negative `integer` or `real` if the first argument is
	  less than the second one, a positive `integer` or `real` if the
	  first argument is greater than the second one, or `0` if the
	  arguments are equal; other values indicate that the arguments
	  are unordered. If no `comparator` is provided, the built-in
	  3-way comparison operator is used. An `array` that contains no
	  elements is considered to have been sorted.

	* Returns `true` if `data` is sorted or empty, or `false`
	  otherwise.

`std.array.binary_search(data, target, [comparator])`

	* Finds the first element in `data` that is equal to `target`.
	  The principle of user-defined `comparator`s is the same as the
	  `is_sorted()` function. As a consequence, the function call
	  `is_sorted(data, comparator)` shall yield `true` prior to this
	  call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an `integer`, if
	  one is found, or `null` otherwise.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.lower_bound(data, target, [comparator])`

	* Finds the first element in `data` that is greater than or equal
	  to `target` and precedes all elements that are less than
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an `integer`. This
	  function returns `lengthof(data)` if all elements are less than
	  `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.upper_bound(data, target, [comparator])`

	* Finds the first element in `data` that is greater than `target`
	  and precedes all elements that are less than or equal to
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an `integer`. This
	  function returns `lengthof(data)` if all elements are less than
	  or equal to `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.equal_range(data, target, [comparator])`

	* Gets the range of elements equivalent to `target` in `data` as
	  a single function call. This function is equivalent to calling
	  `lower_bound(data, target, comparator)` and
	  `upper_bound(data, target, comparator)` respectively then
	  storing both results in an `array`.

	* Returns an `array` of two `integer`s, the first of which
	  specifies the lower bound and the other specifies the upper
	  bound.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.sort(data, [comparator])`

	* Sorts elements in `data` in ascending order. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`, and shall be stable.
	  This function returns a new `array` without modifying `data`.

	* Returns the sorted `array`.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.sortu(data, [comparator])`

	* Sorts elements in `data` in ascending order, then removes all
	  elements that have preceding equivalents. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`. This function returns
	  a new `array` without modifying `data`.

	* Returns the sorted `array` with no duplicate elements.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.max_of(data, [comparator])`

	* Finds the maximum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the maximum element, or `null` if `data` is
	  empty.

`std.array.min_of(data, [comparator])`

	* Finds the minimum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the minimum element, or `null` if `data` is
	  empty.

`std.array.reverse(data)`

	* Reverses an `array`. This function returns a new `array`
	  without modifying `text`.

	* Returns the reversed `array`.

`std.array.generate(generator, length)`

	* Calls `generator` repeatedly up to `length` times and returns
	  an `array` consisting of all values returned. `generator` shall
	  be a binary function. The first argument will be the number of
	  elements having been generated; the second argument is the
	  previous element generated, or `null` in the case of the first
	  element.

	* Returns an `array` containing all values generated.

`std.array.shuffle(data, [seed])`

	* Shuffles elements in `data` randomly. If `seed` is set to an
	  `integer`, the internal pseudo random number generator will be
	  initialized with it and will produce the same series of numbers
	  for a specific `seed` value. If it is absent, an unspecified
	  seed is generated when this function is called. This function
	  returns a new `array` without modifying `data`.

	* Returns the shuffled `array`.

`std.array.copy_keys([source])`

	* Copies all keys from `source`, which shall be an `object`, to
	  create an `array`.

	* Returns an `array` of all keys in `source`. If `source` is
	  `null`, `null` is returned.

`std.array.copy_values([source])`

	* Copies all values from `source`, which shall be an `object`, to
	  create an `array`.

	* Returns an `array` of all values in `source`. If `source` is
	  `null`, `null` is returned.

### `std.numeric`

`std.numeric.integer_max`

	* Denotes the maximum value of an `integer`; that is, the value
	  `+0x7FFFFFFFFFFFFFFF`.

`std.numeric.integer_min`

	* Denotes the minimum value of an `integer`; that is, the value
	  `-0x8000000000000000`.

`std.numeric.real_max`

	* Denotes the maximum finite value of a `real`; that is, the
	  value `+0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_min`

	* Denotes the minimum finite value of a `real`; that is, the
	  value `-0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_epsilon`

	* Denotes the minimum finite value of a `real` such that
	  `1 + real_epsilon > 1`; that is, `+0x1p-52`.

`std.numeric.size_max`

	* Denotes the maximum length of a `string` or `array`. This value
	  is implementation-dependent. Please be advised that there is no
	  guarantee that allocation of a `string` containing this number
	  of bytes will actually succeed or not.

`std.numeric.abs(value)`

	* Gets the absolute value of `value`, which may be an `integer`
	  or `real`. Negative `integer`s are negated, which might cause
	  an exception to be thrown due to overflow. Sign bits of `real`s
	  are removed, which works on infinities and NaNs and does not
	  result in exceptions.

	* Return the absolute value.

	* Throws an exception if `value` is the `integer` `-0x1p63`.

`std.numeric.sign(value)`

	* Propagates the sign bit of the number `value`, which may be an
	  `integer` or `real`, to all bits of an `integer`. Be advised
	  that `-0.0` is distinct from `0.0` despite the equality.

	* Returns `-1` if `value` is negative, or `0` otherwise.

`std.numeric.is_finite(value)`

	* Checks whether `value` is a finite number. `value` may be an
	  `integer` or `real`. Be adviced that this functions returns
	  `true` for `integer`s for consistency; `integer`s do not
	  support infinities or NaNs.

	* Returns `true` if `value` is an `integer` or is a `real` that
	  is neither an infinity or a NaN, or `false` otherwise.

`std.numeric.is_infinity(value)`

	* Checks whether `value` is an infinity. `value` may be an
	  `integer` or `real`. Be adviced that this functions returns
	  `false` for `integer`s for consistency; `integer`s do not
	  support infinities.

	* Returns `true` if `value` is a `real` that denotes an infinity;
	  or `false` otherwise.

`std.numeric.is_nan(value)`

	* Checks whether `value` is a NaN. `value` may be an `integer` or
	  `real`. Be adviced that this functions returns `false` for
	  `integer`s for consistency; `integer`s do not support NaNs.

	* Returns `true` if `value` is a `real` denoting a NaN, or
	  `false` otherwise.

`std.numeric.clamp(value, lower, upper)`

	* Limits `value` between `lower` and `upper`.

	* Returns `lower` if `value < lower`, `upper` if `value > upper`,
	  or `value` otherwise, including when `value` is a NaN. The
	  returned value is of type `integer` if all arguments are of
	  type `integer`; otherwise it is of type `real`.

	* Throws an exception if `lower` is not less than or equal to
	  `upper`.

`std.numeric.round(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer; halfway values are rounded away from zero. If
	  `value` is an `integer`, it is returned intact.

	* Returns the rounded value.

`std.numeric.floor(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards negative infinity. If `value` is an
	  `integer`, it is returned intact.

	* Returns the rounded value.

`std.numeric.ceil(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards positive infinity. If `value` is an
	  `integer`, it is returned intact.

	* Returns the rounded value.

`std.numeric.trunc(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards zero. If `value` is an `integer`, it is
	  returned intact.

	* Returns the rounded value.

`std.numeric.iround(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer; halfway values are rounded away from zero. If
	  `value` is an `integer`, it is returned intact. If `value` is a
	  `real`, it is converted to an `integer`.

	* Returns the rounded value as an `integer`.

	* Throws an exception if the result cannot be represented as an
	  `integer`.

`std.numeric.ifloor(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards negative infinity. If `value` is an
	  `integer`, it is returned intact. If `value` is a `real`, it is
	  converted to an `integer`.

	* Returns the rounded value as an `integer`.

	* Throws an exception if the result cannot be represented as an
	  `integer`.

`std.numeric.iceil(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards positive infinity. If `value` is an
	  `integer`, it is returned intact. If `value` is a `real`, it is
	  converted to an `integer`.

	* Returns the rounded value as an `integer`.

	* Throws an exception if the result cannot be represented as an
	  `integer`.

`std.numeric.itrunc(value)`

	* Rounds `value`, which may be an `integer` or `real`, to the
	  nearest integer towards zero. If `value` is an `integer`, it is
	  returned intact. If `value` is a `real`, it is converted to an
	  `integer`.

	* Returns the rounded value as an `integer`.

	* Throws an exception if the result cannot be represented as an
	  `integer`.

`std.numeric.random([limit])`

	* Generates a random `real` value whose sign agrees with `limit`
	  and whose absolute value is less than `limit`. If `limit` is
	  absent, `1` is assumed.

	* Returns a random `real` value.

	* Throws an exception if `limit` is zero or non-finite.

`std.numeric.sqrt(x)`

	* Calculates the square root of `x` which may be of either the
	  `integer` or the `real` type. The result is always exact.

	* Returns the square root of `x` as a `real`.

`std.numeric.fma(x, y, z)`

	* Performs fused multiply-add operation on `x`, `y` and `z`. This
	  functions calculates `x * y + z` without intermediate rounding
	  operations. The result is always exact.

	* Returns the value of `x * y + z` as a `real`.

`std.numeric.remainder(x, y)`

	* Calculates the IEEE floating-point remainder of division of `x`
	  by `y`. The remainder is defined to be `x - q * y` where `q` is
	  the quotient of division of `x` by `y` rounding to nearest.

	* Returns the remainder as a `real`.

`std.numeric.frexp(x)`

	* Decomposes `x` into normalized fractional and exponent parts
	  such that `x = frac * pow(2,exp)` where `frac` and `exp` denote
	  the fraction and the exponent respectively and `frac` is always
	  within the range `[0.5,1.0)`. If `x` is non-finite, `exp` is
	  unspecified.

	* Returns an `array` having two elements, whose first element is
	  `frac` that is of type `real` and whose second element is `exp`
	  that is of type `integer`.

`std.numeric.ldexp(frac, exp)`

	* Composes `frac` and `exp` to make a `real` number `x`, as if by
	  multiplying `frac` with `pow(2,exp)`. `exp` shall be of type
	  `integer`. This function is the inverse of `frexp()`.

	* Returns the product as a `real`.

`std.numeric.addm(x, y)`

	* Adds `y` to `x` using modular arithmetic. `x` and `y` must be
	  of the `integer` type. The result is reduced to be congruent to
	  the sum of `x` and `y` modulo `0x1p64` in infinite precision.
	  This function will not cause overflow exceptions to be thrown.

	* Returns the reduced sum of `x` and `y`.

`std.numeric.subm(x, y)`

	* Subtracts `y` from `x` using modular arithmetic. `x` and `y`
	  must be of the `integer` type. The result is reduced to be
	  congruent to the difference of `x` and `y` modulo `0x1p64` in
	  infinite precision. This function will not cause overflow
	  exceptions to be thrown.

	* Returns the reduced difference of `x` and `y`.

`std.numeric.mulm(x, y)`

	* Multiplies `x` by `y` using modular arithmetic. `x` and `y`
	  must be of the `integer` type. The result is reduced to be
	  congruent to the product of `x` and `y` modulo `0x1p64` in
	  infinite precision. This function will not cause overflow
	  exceptions to be thrown.

	* Returns the reduced product of `x` and `y`.

`std.numeric.adds(x, y)`

	* Adds `y` to `x` using saturating arithmetic. `x` and `y` may be
	  `integer` or `real` values. The result is limited within the
	  range of representable values of its type, hence will not cause
	  overflow exceptions to be thrown. When either argument is of
	  type `real` which supports infinities, this function is
	  equivalent to the built-in addition operator.

	* Returns the saturated sum of `x` and `y`.

`std.numeric.subs(x, y)`

	* Subtracts `y` from `x` using saturating arithmetic. `x` and `y`
	  may be `integer` or `real` values. The result is limited within
	  the range of representable values of its type, hence will not
	  cause overflow exceptions to be thrown. When either argument is
	  of type `real` which supports infinities, this function is
	  equivalent to the built-in subtraction operator.

	* Returns the saturated difference of `x` and `y`.

`std.numeric.muls(x, y)`

	* Multiplies `x` by `y` using saturating arithmetic. `x` and `y`
	  may be `integer` or `real` values. The result is limited within
	  the range of representable values of its type, hence will not
	  cause overflow exceptions to be thrown. When either argument is
	  of type `real` which supports infinities, this function is
	  equivalent to the built-in multiplication operator.

	* Returns the saturated product of `x` and `y`.

`std.numeric.lzcnt(x)`

	* Counts the number of leading zero bits in `x`, which shall be
	  of type `integer`.

	* Returns the bit count as an `integer`. If `x` is zero, `64` is
	  returned.

`std.numeric.tzcnt(x)`

	* Counts the number of trailing zero bits in `x`, which shall be
	  of type `integer`.

	* Returns the bit count as an `integer`. If `x` is zero, `64` is
	  returned.

`std.numeric.popcnt(x)`

	* Counts the number of one bits in `x`, which shall be of type
	  `integer`.

	* Returns the bit count as an `integer`.

`std.numeric.format(value, [base], [ebase])`

	* Converts an `integer` or `real` to a `string` in `base`. This
	  function writes as many digits as possible to ensure precision.
	  No plus sign precedes the significant figures. If `base` is
	  absent, `10` is assumed. If `ebase` is specified, an exponent
	  is appended to the significand as follows: If `value` is of
	  type `integer`, the significand is kept as short as possible;
	  otherwise (when `value` is of type `real`), it is written in
	  scientific notation, whose significand always contains a
	  decimal point. In both cases, the exponent comprises a plus or
	  minus sign and at least two digits. If `ebase` is absent, no
	  exponent appears. The result is exact as long as `base` is a
	  power of two.

	* Returns a `string` converted from `value`.

	* Throws an exception if `base` is neither `2` nor `10` nor `16`,
	  or if `ebase` is neither `2` nor `10`, or if `base` is not `10`
	  but `ebase` is `10`.

`std.numeric.parse_integer(text)`

	* Parses `text` for an `integer`. `text` shall be a `string`. All
	  leading and trailing blank characters are stripped from `text`.
	  If it becomes empty, this function fails; otherwise, it shall
	  match one of the following Perl regular expressions, ignoring
	  case of characters:

	  * Binary (base-2):
	    `[+-]?0b([01]`?)+[ep][+]?([0-9]`?)+`
	  * Hexadecimal (base-16):
	    `[+-]?0x([0-9a-f]`?)+[ep][+]?([0-9]`?)+`
	  * Decimal (base-10):
	    `[+-]?([0-9]`?)+[ep][+]?([0-9]`?)+`

	  If the string does not match any of the above, this function
	  fails. If the result is outside the range of representable
	  values of type `integer`, this function fails.

	* Returns the `integer` value converted from `text`. On failure,
	  `null` is returned.

`std.numeric.parse_real(text, [saturating])`

	* Parses `text` for a `real`. `text` shall be a `string`. All
	  leading and trailing blank characters are stripped from `text`.
	  If it becomes empty, this function fails; otherwise, it shall
	  match any of the following Perl regular expressions, ignoring
	  case of characters:

	  * Infinities:
	    `[+-]?infinity`
	  * NaNs:
	    `[+-]?nan`
	  * Binary (base-2):
	    `[+-]?0b([01]`?)+(\.([01]`?))?[ep][-+]?([0-9]`?)+`
	  * Hexadecimal (base-16):
	    `[+-]?0x([0-9a-f]`?)+(\.([0-9a-f]`?))?[ep][-+]?([0-9]`?)+`
	  * Decimal (base-10):
	    `[+-]?([0-9]`?)+(\.([0-9]`?))?[ep][-+]?([0-9]`?)+`

	  If the string does not match any of the above, this function
	  fails. If the absolute value of the result is too small to fit
	  in a `real`, a signed zero is returned. When the absolute value
	  is too large, if `saturating` is set to `true`, a signed
	  infinity is returned; otherwise this function fails.

	* Returns the `real` value converted from `text`. On failure,
	  `null` is returned.

### `std.math`

`std.math.e`

	* Denotes the base of the natural logarithm; that is,
	  `2.7182818284590452353602874713526624977572470937000`.

`std.math.pi`

	* Denotes the ratio of a circle's circumference to its diameter;
	  that is, `3.1415926535897932384626433832795028841971693993751`.

`std.math.lb10`

	* Denotes the binary logarithm of the integer ten; that is,
	  `3.3219280948873623478703194294893901758648313930246`.

`std.math.exp(y, [base])`

	* Calculates `base` raised to the power `y`. If `base` is absent,
	  `e` is assumed. This function is equivalent to `pow(base, y)`.

	* Returns the power as a `real`.

`std.math.expm1(y)`

	* Calculates `exp(y) - 1` without losing precision when `y` is
	  close to zero.

	* Returns the result as a `real`.

`std.math.pow(x, y)`

	* Calculates `x` raised to the power `y`. According to C99, when
	  `x` is `1` or `y` is `0`, the result is always `1`, even when
	  the other argument is an infinity or NaN.

	* Returns the power as a `real`.

`std.math.log(x, [base])`

	* Calculates the logarithm of `x` to `base`. If `base` is absent,
	  `e` is assumed.

	* Returns the logarithm as a `real`.

`std.math.log1p(x)`

	* Calculates `log(1 + x)` without losing precision when `x` is
	  close to zero.

	* Returns the result as a `real`.

`std.math.sin(x)`

	* Calculates the sine of `x` in radians.

	* Returns the result as a `real`.

`std.math.cos(x)`

	* Calculates the cosine of `x` in radians.

	* Returns the result as a `real`.

`std.math.tan(x)`

	* Calculates the tangent of `x` in radians.

	* Returns the result as a `real`.

`std.math.asin(x)`

	* Calculates the inverse sine of `x` in radians.

	* Returns the result as a `real`.

`std.math.acos(x)`

	* Calculates the inverse cosine of `x` in radians.

	* Returns the result as a `real`.

`std.math.atan(x)`

	* Calculates the inverse tangent of `x` in radians.

	* Returns the result as a `real`.

`std.math.atan2(y, x)`

	* Calculates the angle of the vector `<x,y>` in radians.

	* Returns the result as a `real`.

`std.math.hypot(...)`

	* Calculates the length of the n-dimension vector defined by all
	  arguments. If no argument is provided, this function returns
	  zero. If any argument is an infinity, this function returns a
	  positive infinity; otherwise, if any argument is a NaN, this
	  function returns a NaN.

	* Returns the length as a `real`.

`std.math.sinh(x)`

	* Calculates the hyperbolic sine of `x`.

	* Returns the result as a `real`.

`std.math.cosh(x)`

	* Calculates the hyperbolic cosine of `x`.

	* Returns the result as a `real`.

`std.math.tanh(x)`

	* Calculates the hyperbolic tangent of `x`.

	* Returns the result as a `real`.

`std.math.asinh(x)`

	* Calculates the inverse hyperbolic sine of `x`.

	* Returns the result as a `real`.

`std.math.acosh(x)`

	* Calculates the inverse hyperbolic cosine of `x`.

	* Returns the result as a `real`.

`std.math.atanh(x)`

	* Calculates the inverse hyperbolic tangent of `x`.

	* Returns the result as a `real`.

`std.math.erf(x)`

	* Calculates the error function of `x`.

	* Returns the result as a `real`.

`std.math.cerf(x)`

	* Calculates the complementary error function of `x`.

	* Returns the result as a `real`.

`std.math.gamma(x)`

	* Calculates the Gamma function of `x`.

	* Returns the result as a `real`.

`std.math.lgamma(x)`

	* Calculates the natural logarithm of the absolute value of the
	  Gamma function of `x`.

	* Returns the result as a `real`.

### `std.filesystem`

`std.filesystem.get_working_directory()`

	* Gets the absolute path of the current working directory.

	* Returns a `string` containing the path to the current working
	  directory.

`std.filesystem.get_information(path)`

	* Retrieves information of the file or directory designated by
	  `path`.

	* Returns an `object` consisting of the following members (names
	  that start with `b_` are `boolean` flags; names that start with
	  `i_` are IDs as `integer`s; names that start with `n_` are
	  plain `integer`s; names that start with `t_` are timestamps in
	  UTC as `integer`s):

	  * `i_dev`   unique device id on this machine.
	  * `i_file`  unique file id on this device.
	  * `n_ref`   number of hard links to this file.
	  * `b_dir`   whether this is a directory.
	  * `b_sym`   whether this is a symbolic link.
	  * `n_size`  number of bytes this file contains.
	  * `n_ocup`  number of bytes this file occupies.
	  * `t_accs`  timestamp of last access.
	  * `t_mod`   timestamp of last modification.

	  On failure, `null` is returned.

`std.filesystem.move_from(path_new, path_old)`

	* Moves (renames) the file or directory at `path_old` to
	  `path_new`.

	* Returns `true` on success, or `null` on failure.

`std.filesystem.remove_recursive(path)`

	* Removes the file or directory at `path`. If `path` designates
	  a directory, all of its contents are removed recursively.

	* Returns the number of files and directories that have been
	  successfully removed in total, or `null` on failure.

`std.filesystem.directory_list(path)`

	* Lists the contents of the directory at `path`.

	* Returns an `object` containing all entries of the directory at
	  `path`, including the special subdirectories '.' and '..'. For
	  each element, its key specifies the filename and the value is
	  an `object` consisting of the following members (names that
	  start with `b_` are `boolean` flags; names that start with `i_`
	  are IDs as `integer`s):

	  * `b_dir`   whether this is a directory.
	  * `b_sym`   whether this is a symbolic link.

	  On failure, `null` is returned.

`std.filesystem.directory_create(path)`

	* Creates a directory at `path`. Its parent directory must exist
	  and must be accessible. This function does not fail if either
	  a directory or a symbolic link to a directory already exists on
	  `path`.

	* Returns `1` if a new directory has been created successfully,
	  `0` if the directory already exists, or `null` on failure.

`std.filesystem.directory_remove(path)`

	* Removes the directory at `path`. The directory must be empty.
	  This function fails if `path` does not designate a directory.

	* Returns `1` if the directory has been removed successfully, `0`
	  if it is not empty, or `null` on failure.

`std.filesystem.file_read(path, [offset], [limit])`

	* Reads the file at `path` in binary mode. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns the bytes that have been read as a `string`, or `null`
	  on failure.

	* Throws an exception if `offset` is negative.

`std.filesystem.file_stream(path, callback, [offset], [limit])`

	* Reads the file at `path` in binary mode and invokes `callback`
	  with the data read repeatedly. `callback` shall be a binary
	  `function` whose first argument is the absolute offset of the
	  data block that has been read, and whose second argument is the
	  bytes read and stored in a `string`. Data may be transferred in
	  multiple blocks of variable sizes; the caller shall make no
	  assumption about the number of times that `callback` will be
	  called or the size of each individual block. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns `true` if all data have been processed successfully, or
	  `null` on failure.

	* Throws an exception if `offset` is negative.

`std.filesystem.file_write(path, data, [offset])`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. The
	  file is truncated to this length before the write operation;
	  any existent contents after the write point are discarded. This
	  function fails if the data can only be written partially.

	* Returns `true` if all data have been written successfully, or
	  `null` on failure.

	* Throws an exception if `offset` is negative.

`std.filesystem.file_append(path, data, [exclusive])`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the end of the file; existent contents of the file
	  are left intact. If `exclusive` is `true` and a file exists on
	  `path`, this function fails. This function also fails if the
	  data can only be written partially.

	* Returns `true` if all data have been written successfully, or
	  `null` on failure.

`std.filesystem.file_copy_from(path_new, path_old)`

	* Copies the file `path_old` to `path_new`. If `path_old` is a
	  symbolic link, it is the target that will be copied, rather
	  than the symbolic link itself. This function fails if
	  `path_old` designates a directory.

	* Returns `true` on success, or `null` on failure.

`std.filesystem.file_remove(path)`

	* Removes the file at `path`. This function fails if `path`
	  designates a directory.

	* Returns `true` if the file has been removed successfully, or
	  `null` on failure.

### `std.checksum`

`std.checksum.crc32_new()`

	* Creates a CRC-32 hasher according to ISO/IEC 3309. The divisor
	  is `0x04C11DB7` (or `0xEDB88320` in reverse form).

	* Returns the hasher as an `object` consisting of the following
	  members:

	  * `write(data)`
	  * `finish()`

	  The function `write()` is used to put data into the hasher,
	  which shall be of type `string`. After all data have been put,
	  the function `finish()` extracts the checksum as an `integer`
	  (whose high-order 32 bits are always zeroes), then resets the
	  hasher, making it suitable for further data as if it had just
	  been created.

`std.checksum.crc32(data)`

	* Calculates the CRC-32 checksum of `data` which must be of type
	  `string`, as if this function was defined as

	  ```
	    std.checksum.crc32 = func(data) {
	      var h = this.crc32_new();
	      h.write(data);
	      return h.finish();
	    };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the CRC-32 checksum as an `integer`. The high-order 32
	  bits are always zeroes.

`std.checksum.fnv1a32_new()`

	* Creates a 32-bit Fowler-Noll-Vo (a.k.a. FNV) hasher of the
	  32-bit FNV-1a variant. The FNV prime is `16777619` and the FNV
	  offset basis is `2166136261`.

	* Returns the hasher as an `object` consisting of the following
	  members:

	  * `write(data)`
	  * `finish()`

	  The function `write()` is used to put data into the hasher,
	  which shall be of type `string`. After all data have been put,
	  the function `finish()` extracts the checksum as an `integer`
	  (whose high-order 32 bits are always zeroes), then resets the
	  hasher, making it suitable for further data as if it had just
	  been created.

`std.checksum.fnv1a32(data)`

	* Calculates the 32-bit FNV-1a checksum of `data` which must be
	  of type `string`, as if this function was defined as

	  ```
	    std.checksum.fnv1a32 = func(data) {
	      var h = this.fnv1a32_new();
	      h.write(data);
	      return h.finish();
	    };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the 32-bit FNV-1a checksum as an `integer`. The
	  high-order 32 bits are always zeroes.

`std.checksum.md5_new()`

	* Creates an MD5 hasher.

	* Returns the hasher as an `object` consisting of the following
	  members:

	  * `write(data)`
	  * `finish()`

	  The function `write()` is used to put data into the hasher,
	  which shall be of type `string`. After all data have been put,
	  the function `finish()` extracts the checksum as a `string` of
	  32 hexadecimal digits in uppercase, then resets the hasher,
	  making it suitable for further data as if it had just been
	  created.

`std.checksum.md5(data)`

	* Calculates the MD5 checksum of `data` which must be of type
	  `string`, as if this function was defined as

	  ```
	    std.checksum.md5 = func(data) {
	      var h = this.md5_new();
	      h.write(data);
	      return h.finish();
	    };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the MD5 checksum as a `string` of 32 hexadecimal digits
	  in uppercase.

`std.checksum.sha1_new()`

	* Creates an SHA-1 hasher.

	* Returns the hasher as an `object` consisting of the following
	  members:

	  * `write(data)`
	  * `finish()`

	  The function `write()` is used to put data into the hasher,
	  which shall be of type `string`. After all data have been put,
	  the function `finish()` extracts the checksum as a `string` of
	  40 hexadecimal digits in uppercase, then resets the hasher,
	  making it suitable for further data as if it had just been
	  created.

`std.checksum.sha1(data)`

	* Calculates the SHA-1 checksum of `data` which must be of type
	  `string`, as if this function was defined as

	  ```
	    std.checksum.sha1 = func(data) {
	      var h = this.sha1_new();
	      h.write(data);
	      return h.finish();
	    };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-1 checksum as a `string` of 40 hexadecimal
	  digits in uppercase.

`std.checksum.sha256_new()`

	* Creates an SHA-256 hasher.

	* Returns the hasher as an `object` consisting of the following
	  members:

	  * `write(data)`
	  * `finish()`

	  The function `write()` is used to put data into the hasher,
	  which shall be of type `string`. After all data have been put,
	  the function `finish()` extracts the checksum as a `string` of
	  64 hexadecimal digits in uppercase, then resets the hasher,
	  making it suitable for further data as if it had just been
	  created.

`std.checksum.sha256(data)`

	* Calculates the SHA-256 checksum of `data` which must be of type
	  `string`, as if this function was defined as

	  ```
	    std.checksum.sha256 = func(data) {
	      var h = this.sha256_new();
	      h.write(data);
	      return h.finish();
	    };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-256 checksum as a `string` of 64 hexadecimal
	  digits in uppercase.

### `std.json`

`std.json.format(value, [indent])`

	* Converts a value to a `string` in the JSON format, according to
	  IETF RFC 7159. This function generates text that conforms to
	  JSON strictly; values whose types cannot be represented in JSON
	  are discarded if they are found in an `object` and censored to
	  `null` otherwise. If `indent` is set to a `string`, it is used
	  as each level of indention following a line break, unless it is
	  empty, in which case no line break is inserted. If `indent` is
	  set to an `integer`, it is clamped between `0` and `10`
	  inclusively and this function behaves as if a `string`
	  consisting of this number of spaces was set. Its default value
	  is an empty `string`.

	* Returns the formatted text as a `string`.

`std.json.parse(text)`

	* Parses a `string` containing data encoded in the JSON format
	  and converts it to a value. This function reuses the tokenizer
	  of Asteria and allows quite a few extensions, some of which
	  are also supported by JSON5:

	  * Single-line and multiple-line comments are allowed.
	  * Binary and hexadecimal numbers are allowed.
	  * Numbers can have binary exponents.
	  * Infinities and NaNs are allowed.
	  * Numbers can start with plus signs.
	  * Strings and object keys may be single-quoted.
	  * Escape sequences (including UTF-32) are allowed in strings.
	  * Element lists of arrays and objects may end in commas.
	  * Object keys may be unquoted if they are valid identifiers.

	  Be advised that numbers are always parsed as `real`s.

	* Returns the parsed value. If `text` is empty or is not a valid
	  JSON string, `null` is returned. There is no way to tell empty
	  or explicit `"null"` inputs from failures.
