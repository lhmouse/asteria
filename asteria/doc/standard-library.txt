### `std.version`

`std.version.major`

	* Denotes the major version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

`std.version.minor`

	* Denotes the minor version number of the standard library that
	  has been enabled. This member is always set, even when there is
	  no standard library.

### `std.system`

`std.system.gc_count_variables(generation)`

	* Gets the number of variables that are being tracked by the
	  collector for `generation`. Valid values for `generation` are
	  `0`, `1` and `2`.

	* Returns the number of variables being tracked. This value is
	  only informative. If `generation` is not valid, `null` is
	  returned.

`std.system.gc_get_threshold(generation)`

	* Gets the threshold of the collector for `generation`. Valid
	  values for `generation` are `0`, `1` and `2`.

	* Returns the threshold. If `generation` is not valid, `null` is
	  returned.

`std.system.gc_set_threshold(generation, threshold)`

	* Sets the threshold of the collector for `generation` to
	  `threshold`. Valid values for `generation` are `0`, `1` and
	  `2`. Valid values for `threshold` range from `0` to an
	  unspecified positive integer; overlarge values are capped
	  silently without failure. A larger `threshold` makes garbage
	  collection run less often but slower. Setting `threshold` to
	  `0` ensures all unreachable variables be collected immediately.

	* Returns the threshold before the call. If `generation` is not
	  valid, `null` is returned.

`std.system.gc_collect([generation_limit])`

	* Performs garbage collection on all generations including and
	  up to `generation_limit`. If it is absent, all generations are
	  collected.

	* Returns the number of variables that have been collected in
	  total.

`std.system.env_get_variable(name)`

	* Retrieves an environment variable with `name`.

	* Returns the environment variable's value if a match is found,
	  or `null` if no such variable exists.

	* Throws an exception if `name` is not valid.

`std.system.env_get_variables()`

	* Retrieves all environment variables.

	* Returns an object of strings which consists of copies of all
	  environment variables.

`std.system.uuid([lowercase])`

	* Generates a UUID according to the following specification:

	  Canonical form: `xxxxxxxx-xxxx-Myyy-Nzzz-wwwwwwwwwwww`

          * x: number of 1/30,518 seconds since UNIX Epoch
          * M: always `4` (UUID version)
          * y: process ID
          * N: any of `0`-`7` (UUID variant)
          * z: context ID
          * w: random bytes

          Unlike version-1 UUIDs in RFC 4122, the timestamp is written
          in pure big-endian order. This ensures the case-insensitive
          lexicographical order of such UUIDs will match their order of
          creation. If `lowercase` is set to `true`, hexadecimal digits
          above `9` are encoded as `abcdef`; otherwise they are encoded
          as `ABCDEF`.

	* Returns a UUID as a string of 36 characters without braces.

`std.system.proc_get_pid()`

	* Gets the ID of the current process.

	* Returns the process ID as an integer.

`std.system.proc_get_ppid()`

	* Gets the ID of the parent process.

	* Returns the parent process ID as an integer.

`std.system.proc_get_uid()`

	* Gets the real user ID of the current process.

	* Returns the real user ID as an integer.

`std.system.proc_get_euid()`

	* Gets the effective user ID of the current process.

	* Returns the effective user ID as an integer.

`std.system.proc_invoke(cmd, [argv], [envp])`

	* Launches the program denoted by `cmd`, awaits its termination,
	  and returns its exit status. If `argv` is provided, it shall be
	  an array of strings, which specify additional arguments to pass
	  to the program along with `cmd`. If `envp` is specified, it
	  shall also be an array of strings, which specify environment
	  variables to pass to the program.

	* Returns the exit status as an integer. If the process exits due
	  to a signal, the exit status is `128+N` where `N` is the signal
	  number.

	* Throws an exception if the program could not be launched or its
	  exit status could not be retrieved.

`std.system.proc_daemonize()`

	* Detaches the current process from its controlling terminal and
	  continues in the background. The calling process terminates on
	  success so this function never returns.

	* Throws an exception on failure.

`std.system.conf_load_file(path)`

	* Loads the configuration file denoted by `path`. Its syntax is
	  similar to JSON5, except that commas, semicolons and top-level
	  braces are omitted for simplicity, and single-quoted strings do
	  not support escapes. A sample configuration file can be found
	  at 'doc/sample.conf'.

	* Returns an object of all values from the file, if it was parsed
	  successfully.

	* Throws an exception if the file could not be opened, or there
	  was an error in it.

### `std.debug`

`std.debug.logf(templ, ...)`

	* Compose a string in the same way as `std.string.format()`, but
	  instead of returning it, write it to standard error. A line
	  break is appended to terminate the line.

	* Returns the number of bytes written if the operation succeeds,
	  or `null` otherwise.

`std.debug.dump(value, [indent])`

	* Prints the value to standard error with detailed information.
	  `indent` specifies the number of spaces to use as a single
	  level of indent. Its value is clamped between `0` and `10`
	  inclusively. If it is set to `0`, no line break is inserted and
	  output lines are not indented. It has a default value of `2`.

	* Returns the number of bytes written if the operation succeeds,
	  or `null` otherwise.

### `std.chrono`

`std.chrono.utc_now()`

	* Retrieves the wall clock time in UTC.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an integer.

`std.chrono.local_now()`

	* Retrieves the wall clock time in the local time zone.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an integer.

`std.chrono.hires_now()`

	* Retrieves a time point from a high resolution clock. The clock
	  goes monotonically and cannot be adjusted, being suitable for
	  time measurement. This function provides accuracy and might be
	  quite heavyweight.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as a real.

`std.chrono.steady_now()`

	* Retrieves a time point from a steady clock. The clock goes
	  monotonically and cannot be adjusted, being suitable for time
	  measurement. This function is supposed to be fast and might
	  have poor accuracy.

	* Returns the number of milliseconds since an unspecified time
	  point, represented as an integer.

`std.chrono.local_from_utc(time_utc)`

	* Converts a UTC time point to a local one. `time_utc` shall be
	  the number of milliseconds since the Unix epoch.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`
	  in the local time zone, represented as an integer.

`std.chrono.utc_from_local(time_local)`

	* Converts a local time point to a UTC one. `time_local` shall
	  be the number of milliseconds since `1970-01-01 00:00:00` in
	  the local time zone.

	* Returns the number of milliseconds since the Unix epoch,
	  represented as an integer.

`std.chrono.utc_format(time_point, [with_ms])`

	* Converts `time_point`, which represents the number of
	  milliseconds since `1970-01-01 00:00:00`, to an ASCII string in
	  the aforementioned format, according to the ISO 8601 standard.
	  If `with_ms` is set to `true`, the string will have a 3-digit
	  fractional part. By default, no fractional part is added.

	* Returns a string representing the time point.

`std.chrono.utc_parse(time_str)`

	* Parses `time_str`, which is an ASCII string representing a time
	  point in the format `1970-01-01 00:00:00.000`, according to the
	  ISO 8601 standard. The subsecond part is optional and may have
	  fewer or more digits. There may be leading or trailing spaces.

	* Returns the number of milliseconds since `1970-01-01 00:00:00`.

	* Throws an exception if the string is invalid.

### `std.string`

`std.string.slice(text, from, [length])`

	* Copies a subrange of `text` to create a new byte string. Bytes
	  are copied from `from` if it is non-negative, or from
	  `countof(text) + from` otherwise. If `length` is set to an
	  integer, no more than this number of bytes will be copied. If
	  it is absent, all bytes from `from` to the end of `text` will
	  be copied. If `from` is outside `text`, an empty string is
	  returned.

	* Returns the specified substring of `text`.

`std.string.replace_slice(text, from, replacement)`

	* Replaces all bytes from `from` to the end of `text` with
	  `replacement` and returns the new byte string. If `from` is
	  negative, it specifies an offset from the end of `text`. This
	  function returns a new string without modifying `text`.

	* Returns a string with the subrange replaced.

`std.string.replace_slice(text, from, [length], replacement)`

	* Replaces a subrange of `text` with `replacement` to create a
	  new byte string. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `text`. `length` specifies the maximum number of bytes
	  to replace. If it is set to `null`, this function is equivalent
	  to `replace_slice(text, from, replacement)`. This function
	  returns a new string without modifying `text`.

	* Returns a string with the subrange replaced.

`std.string.compare(text1, text2, [length])`

	* Performs lexicographical comparison on two byte strings. If
	  `length` is set to an integer, no more than this number of
	  bytes are compared. This function behaves like the `strncmp()`
	  function in C, except that null characters do not terminate
	  strings.

	* Returns a positive integer if `text1` compares greater than
	  `text2`, a negative integer if `text1` compares less than
	  `text2`, or zero if `text1` compares equal to `text2`.

`std.string.starts_with(text, prefix)`

	* Checks whether `prefix` is a prefix of `text`. The empty
	  string is considered to be a prefix of any string.

	* Returns `true` if `prefix` is a prefix of `text`, or `false`
	  otherwise.

`std.string.ends_with(text, suffix)`

	* Checks whether `suffix` is a suffix of `text`. The empty
	  string is considered to be a suffix of any string.

	* Returns `true` if `suffix` is a suffix of `text`, or `false`
	  otherwise.

`std.string.find(text, pattern)`

	* Searches `text` for the first occurrence of `pattern`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find(text, from, pattern)`

	* Searches `text` for the first occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find(text, from, [length], pattern)`

	* Searches `text` for the first occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte of the first match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, pattern)`

	* Searches `text` for the last occurrence of `pattern`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, from, pattern)`

	* Searches `text` for the last occurrence of `pattern`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.rfind(text, from, [length], pattern)`

	* Searches `text` for the last occurrence of `pattern`.

	* Returns the subscript of the first byte of the last match of
	  `pattern` in `text` if one is found, which is always
	  non-negative, or `null` otherwise.

`std.string.find_and_replace(text, pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. This function returns a new string without
	  modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_and_replace(text, from, pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. The search operation is performed on the same
	  subrange that would be returned by `slice(text, from)`. This
	  function returns a new string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_and_replace(text, from, [length], pattern, replacement)`

	* Searches `text` and replaces all occurrences of `pattern` with
	  `replacement`. The search operation is performed on the same
	  subrange that would be returned by `slice(text, from, length)`.
	  This function returns a new string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

`std.string.find_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, from, accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_any_of(text, from, [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, accept)`

	* Searches `text` for bytes that exist in `accept`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, from, accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_any_of(text, from, [length], accept)`

	* Searches `text` for bytes that exist in `accept`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, from, reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.find_not_of(text, from, [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the first byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, reject)`

	* Searches `text` for bytes that does not exist in `reject`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, from, reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.rfind_not_of(text, from, [length], reject)`

	* Searches `text` for bytes that does not exist in `reject`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(text, from, length)`.

	* Returns the subscript of the last byte found, which is always
	  non-negative; or `null` if no such byte exists.

`std.string.reverse(text)`

	* Reverses a byte string. This function returns a new string
	  without modifying `text`.

	* Returns the reversed string.

`std.string.trim(text, [reject])`

	* Removes the longest prefix and suffix consisting solely bytes
	  from `reject`. If `reject` is empty, no byte is removed. If
	  `reject` is not specified, spaces and tabs are removed. This
	  function returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.triml(text, [reject])`

	* Removes the longest prefix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.trimr(text, [reject])`

	* Removes the longest suffix consisting solely bytes from
	  `reject`. If `reject` is empty, no byte is removed. If `reject`
	  is not specified, spaces and tabs are removed. This function
	  returns a new string without modifying `text`.

	* Returns the trimmed string.

`std.string.padl(text, length, [padding])`

	* Prepends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  string consisting of a space. This function returns a new
	  string without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.padr(text, length, [padding])`

	* Appends `text` with `padding` repeatedly, until its length
	  would exceed `length`. The default value of `padding` is a
	  string consisting of a space. This function returns a new
	  string without modifying `text`.

	* Returns the padded string.

	* Throws an exception if `padding` is empty.

`std.string.to_upper(text)`

	* Converts all lowercase English letters in `text` to their
	  uppercase counterparts. This function returns a new string
	  without modifying `text`.

	* Returns a new string after the conversion.

`std.string.to_lower(text)`

	* Converts all uppercase English letters in `text` to their
	  lowercase counterparts. This function returns a new string
	  without modifying `text`.

	* Returns a new string after the conversion.

`std.string.translate(text, inputs, [outputs])`

	* Performs bytewise translation on the given string. For every
	  byte in `text` that is also found in `inputs`, if there is a
	  corresponding replacement byte in `outputs` with the same
	  subscript, it is replaced with the latter; if no replacement
	  exists, because `outputs` is shorter than `inputs` or is null,
	  it is deleted. If `outputs` is longer than `inputs`, excess
	  bytes are ignored. Bytes that do not exist in `inputs` are left
	  intact. This function returns a new string without modifying
	  `text`.

	* Returns the translated string.

`std.string.explode(text, [delim], [limit])`

	* Breaks `text` down into segments, separated by `delim`. If
	  `delim` is `null` or an empty string, every byte becomes a
	  segment. If `limit` is set to a positive integer, there will be
	  no more segments than this number; the vert last segment will
	  contain all the remaining bytes of the `text`.

	* Returns an array containing the broken-down segments. If `text`
	  is empty, an empty array is returned.

	* Throws an exception if `limit` is negative or zero.

`std.string.implode(segments, [delim])`

	* Concatenates elements of an array, `segments`, to create a new
	  string. All segments shall be strings. If `delim` is
	  specified, it is inserted between adjacent segments.

	* Returns a string containing all segments. If `segments` is
	  empty, an empty string is returned.

`std.string.hex_encode(data, [lowercase], [delim])`

	* Encodes all bytes in `data` as 2-digit hexadecimal numbers and
	  concatenates them. If `lowercase` is set to `true`, hexadecimal
	  digits above `9` are encoded as `abcdef`; otherwise they are
	  encoded as `ABCDEF`. If `delim` is specified, it is inserted
	  between adjacent bytes.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.hex_decode(text)`

	* Decodes all hexadecimal digits from `text` and converts them to
	  bytes. Whitespaces can be used to delimit bytes; they shall not
	  occur between digits in the same byte. Consequently, the total
	  number of non-whitespace characters must be a multiple of two.
	  Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.base32_encode(data, [lowercase])`

	* Encodes all bytes in `data` according to the base32 encoding
	  specified by IETF RFC 4648. If `lowercase` is set to `true`,
	  lowercase letters are used to represent values through `0` to
	  `25`; otherwise, uppercase letters are used. The length of
	  encoded data is always a multiple of 8; padding characters are
	  mandatory.

	* Returns the encoded string.

`std.string.base32_decode(text)`

	* Decodes data encoded in base32, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  eight. Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.base64_encode(data)`

	* Encodes all bytes in `data` according to the base64 encoding
	  specified by IETF RFC 4648. The length of encoded data is
	  always a multiple of 4; padding characters are mandatory.

	* Returns the encoded string.

`std.string.base64_decode(text)`

	* Decodes data encoded in base64, as specified by IETF RFC 4648.
	  Whitespaces can be used to delimit encoding units; they shall
	  not occur between characters in the same unit. Consequently,
	  the number of non-whitespace characters must be a multiple of
	  four. Invalid characters cause decode errors.

	* Returns a string containing decoded bytes. If `text` is empty
	  or consists of only whitespaces, an empty string is returned.

	* Throws an exception if the string is invalid.

`std.string.url_encode(data, [lowercase])`

	* Encodes bytes in `data` according to IETF RFC 3986. Every byte
	  that is not a letter, digit, `-`, `.`, `_` or `~` is encoded as
	  a `%` followed by two hexadecimal digits. If `lowercase` is set
	  to `true`, lowercase letters are used to represent values
	  through `10` to `15`; otherwise, uppercase letters are used.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.url_decode(text)`

	* Decodes percent-encode sequences from `text` and converts them
	  to bytes according to IETF RFC 3986. For convenience reasons,
	  both reserved and unreserved characters are copied verbatim.
	  Characters that are neither reserved nor unreserved (such as
	  ASCII control characters or non-ASCII characters) cause decode
	  errors.

	* Returns a string containing decoded bytes.

	* Throws an exception if the string contains invalid characters.

`std.string.url_encode_query(data, [lowercase])`

	* Encodes bytes in `data` according to IETF RFC 3986. This
	  function behaves like `url_encode()`, except that characters
	  that are allowed unencoded in query strings are not encoded,
	  and spaces are encoded as `+` instead of the long form `%20`.

	* Returns the encoded string. If `data` is empty, an empty
	  string is returned.

`std.string.url_decode_query(text)`

	* Decodes percent-encode sequences from `text` and converts them
	  to bytes according to IETF RFC 3986. This function behaves like
	  `url_decode()`, except that `+` is decoded as a space.

	* Returns a string containing decoded bytes.

	* Throws an exception if the string contains invalid characters.

`std.string.utf8_validate(text)`

	* Checks whether `text` is a valid UTF-8 string.

	* Returns `true` if `text` is valid, or `false` otherwise.

`std.string.utf8_encode(code_points, [permissive])`

	* Encodes code points from `code_points` into an UTF-8 string.
	  `code_points` can be either an integer or an array of
	  integers. When an invalid code point is encountered, if
	  `permissive` is set to `true`, it is replaced with the
	  replacement character `"\uFFFD"` and consequently encoded as
	  `"\xEF\xBF\xBD"`; otherwise this function fails.

	* Returns the encoded string.

	* Throws an exception on failure.

`std.string.utf8_decode(text, [permissive])`

	* Decodes `text`, which is expected to be a string containing
	  UTF-8 code units, into an array of code points, represented as
	  integers. When an invalid code sequence is encountered, if
	  `permissive` is set to `true`, all code units of it are
	  re-interpreted as isolated bytes according to ISO/IEC 8859-1;
	  otherwise this function fails.

	* Returns an array containing decoded code points.

	* Throws an exception on failure.

`std.string.pack_8(values)`

	* Packs a series of 8-bit integers into a string. `values` can be
	  either an integer or an array of integers, all of which are
	  truncated to 8 bits then copied into a string.

	* Returns the packed string.

`std.string.unpack_8(text)`

	* Unpacks 8-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 8-bit integers, all of
	  which are sign-extended to 64 bits then copied into an array.

	* Returns an array containing unpacked integers.

`std.string.pack_16be(values)`

	* Packs a series of 16-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are truncated to 16 bits then copied into a string in the
	  big-endian byte order.

	* Returns the packed string.

`std.string.unpack_16be(text)`

	* Unpacks 16-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_16le(values)`

	* Packs a series of 16-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are truncated to 16 bits then copied into a string in the
	  little-endian byte order.

	* Returns the packed string.

`std.string.unpack_16le(text)`

	* Unpacks 16-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 16-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 2.

`std.string.pack_32be(values)`

	* Packs a series of 32-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are truncated to 32 bits then copied into a string in the
	  big-endian byte order.

	* Returns the packed string.

`std.string.unpack_32be(text)`

	* Unpacks 32-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  big-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_32le(values)`

	* Packs a series of 32-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are truncated to 32 bits then copied into a string in the
	  little-endian byte order.

	* Returns the packed string.

`std.string.unpack_32le(text)`

	* Unpacks 32-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 32-bit integers in the
	  little-endian byte order, all of which are sign-extended to 64
	  bits then copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 4.

`std.string.pack_64be(values)`

	* Packs a series of 64-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are copied into a string in the big-endian byte order.

	* Returns the packed string.

`std.string.unpack_64be(text)`

	* Unpacks 64-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  big-endian byte order, all of which are copied into an array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.string.pack_64le(values)`

	* Packs a series of 64-bit integers into a string. `values` can
	  be either an integer or an array of `integers`, all of which
	  are copied into a string in the little-endian byte order.

	* Returns the packed string.

`std.string.unpack_64le(text)`

	* Unpacks 64-bit integers from a string. The contents of `text`
	  are re-interpreted as contiguous signed 64-bit integers in the
	  little-endian byte order, all of which are copied into an
	  array.

	* Returns an array containing unpacked integers.

	* Throws an exception if the length of `text` is not a multiple
	  of 8.

`std.string.format(templ, ...)`

	* Compose a string according to the template string `templ`, as
	  follows:

	  * A sequence of `$$` is replaced with a literal `$`.
	  * A sequence of `${NNN}`, where `NNN` is at most three decimal
	    numerals, is replaced with the NNN-th argument. If `NNN` is
	    zero, it is replaced with `templ` itself.
	  * A sequence of `$N`, where `N` is a single decimal numeral,
	    behaves the same as `${N}`.
	  * All other characters are copied verbatim.

	* Returns the composed string.

	* Throws an exception if `templ` contains invalid placeholder
	  sequences, or when a placeholder sequence has no corresponding
	  argument.

`std.string.regex_find(text, pattern)`

	* Searches `text` for the first occurrence of the regular
	  expression `pattern`.

	* Returns an array of two integers, the first of which
	  specifies the subscript of the matching sequence and the second
	  of which specifies its length. If `pattern` is not found, this
	  function returns `null`.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_find(text, from, pattern)`

	* Searches `text` for the first occurrence of the regular
	  expression `pattern`. The search operation is performed on the
	  same subrange that would be returned by `slice(text, from)`.

	* Returns an array of two integers, the first of which
	  specifies the subscript of the matching sequence and the second
	  of which specifies its length. If `pattern` is not found, this
	  function returns `null`.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_find(text, from, [length], pattern)`

	* Searches `text` for the first occurrence of the regular
	  expression `pattern`. The search operation is performed on the
	  same subrange that would be returned by
	  `slice(text, from, length)`.

	* Returns an array of two integers, the first of which
	  specifies the subscript of the matching sequence and the second
	  of which specifies its length. If `pattern` is not found, this
	  function returns `null`.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_match(text, pattern)`

	* Checks whether the regular expression `patterm` matches the
	  entire sequence `text`.

	* Returns an array of optional strings. The first element
	  contains a copy of `text`. All the other elements hold
	  substrings that match positional capturing groups. If a group
	  matches nothing, the corresponding element is `null`. The total
	  number of elements equals the number of capturing groups plus
	  one. If `text` does not match `pattern`, `null` is returned.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_match(text, from, pattern)`

	* Checks whether the regular expression `patterm` matches the
	  subrange that would be returned by `slice(text, from)`.

	* Returns an array of optional strings. The first element
	  contains a copy of `text`. All the other elements hold
	  substrings that match positional capturing groups. If a group
	  matches nothing, the corresponding element is `null`. The total
	  number of elements equals the number of capturing groups plus
	  one. If `text` does not match `pattern`, `null` is returned.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_match(text, from, [length], pattern)`

	* Checks whether the regular expression `patterm` matches the
	  subrange that would be returned by `slice(text, from, length)`.

	* Returns an array of optional strings. The first element
	  contains a copy of `text`. All the other elements hold
	  substrings that match positional capturing groups. If a group
	  matches nothing, the corresponding element is `null`. The total
	  number of elements equals the number of capturing groups plus
	  one. If `text` does not match `pattern`, `null` is returned.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_replace(text, pattern, replacement)`

	* Searches `text` and replaces all matches of the regular
	  expression `pattern` with `replacement`. This function returns
	  a new string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

`std.string.regex_replace(text, from, pattern, replacement)`

	* Searches `text` and replaces all matches of the regular
	  expression `pattern` with `replacement`. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(text, from)`. This function returns a new string
	  without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

	* Throws an exception if either `pattern` or `replacement` is not
	  a valid regular expression.

`std.string.regex_replace(text, from, [length], pattern, replacement)`

	* Searches `text` and replaces all matches of the regular
	  expression `pattern` with `replacement`. The search operation
	  is performed on the same subrange that would be returned by
	  `slice(text, from, length)`. This function returns a new
	  string without modifying `text`.

	* Returns the string with `pattern` replaced. If `text` does not
	  contain `pattern`, it is returned intact.

	* Throws an exception if `pattern` is not a valid regular
	  expression.

### `std.array`

`std.array.slice(data, from, [length])`

	* Copies a subrange of `data` to create a new array. Elements are
	  copied from `from` if it is non-negative, or from
	  `countof(data) + from` otherwise. If `length` is set to an
	  integer, no more than this number of elements will be copied.
	  If it is absent, all elements from `from` to the end of `data`
	  will be copied. If `from` is outside `data`, an empty array
	  is returned.

	* Returns the specified subarray of `data`.

`std.array.replace_slice(data, from, replacement)`

	* Replaces all elements from `from` to the end of `data` with
	  `replacement` and returns the new array. If `from` is negative,
	  it specifies an offset from the end of `data`. This function
	  returns a new array without modifying `data`.

	* Returns a new array with the subrange replaced.

`std.array.replace_slice(data, from, [length], replacement)`

	* Replaces a subrange of `data` with `replacement` to create a
	  new array. `from` specifies the start of the subrange to
	  replace. If `from` is negative, it specifies an offset from the
	  end of `data`. `length` specifies the maximum number of
	  elements to replace. If it is set to `null`, this function is
	  equivalent to `replace_slice(data, from, replacement)`. This
	  function returns a new array without modifying `data`.

	* Returns a new array with the subrange replaced.

`std.array.find(data, target)`

	* Searches `data` for the first occurrence of `target`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find(data, from, target)`

	* Searches `data` for the first occurrence of `target`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(data, from)`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find(data, from, [length], target)`

	* Searches `data` for the first occurrence of `target`. The
	  search operation is performed on the same subrange that would
	  be returned by `slice(data, from, length)`.

	* Returns the subscript of the first match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.find_if(data, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_if(data, from, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_if(data, from, [length], predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_if_not(data, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_if_not(data, from, predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.find_if_not(data, from, [length], predictor)`

	* Finds the first element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind(data, target)`

	* Searches `data` for the last occurrence of `target`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind(data, from, target)`

	* Searches `data` for the last occurrence of `target`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(data, from)`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind(data, from, [length], target)`

	* Searches `data` for the last occurrence of `target`. The search
	  operation is performed on the same subrange that would be
	  returned by `slice(data, from, length)`.

	* Returns the subscript of the last match of `target` in `data`
	  if one is found, which is always non-negative, or `null`
	  otherwise.

`std.array.rfind_if(data, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_if(data, from, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_if(data, from, [length], predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically true. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_if_not(data, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_if_not(data, from, predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.rfind_if_not(data, from, [length], predictor)`

	* Finds the last element, namely `x`, in `data`, for which
	  `predictor(x)` yields logically false. The search operation is
	  performed on the same subrange that would be returned by
	  `slice(data, from, length)`.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

`std.array.count(data, target)`

	* Searches `data` for `target` and figures the total number of
	  occurrences.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count(data, from, target)`

	* Searches `data` for `target` and figures the total number of
	  occurrences. The search operation is performed on the same
	  subrange that would be returned by `slice(data, from)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count(data, from, [length], target)`

	* Searches `data` for `target` and figures the total number of
	  occurrences. The search operation is performed on the same
	  subrange that would be returned by `slice(data, from, length)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if(data, target, predictor)`

	* Searches `data` for every element, namely `x`, such that
	  `predictor(x)` yields logically true, and figures the total
	  number of such occurrences.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if(data, from, target, predictor)`

	* Searches `data` for every element, namely `x`, such that
	  `predictor(x)` yields logically true, and figures the total
	  number of elements. The search operation is performed on the
	  same subrange that would be returned by `slice(data, from)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if(data, from, [length], target, predictor)`

	* Searches `data` for every element, namely `x`, such that
	  `predictor(x)` yields logically true, and figures the total
	  number of elements. The search operation is performed on the
	  same subrange that would be returned by `slice(data, from,
	  length)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if_not(data, target, predictor)`

	* Searches on every element, namely `x`, in `data`, such that
	  `predictor(x)` yields logically false, and figures the total
	  number of such occurrences.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if_not(data, from, target, predictor)`

	* Searches on every element, namely `x`, in `data`, such that
	  `predictor(x)` yields logically false, and figures the total
	  number of elements. The search operation is performed on the
	  same subrange that would be returned by `slice(data, from)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.count_if_not(data, from, [length], target, predictor)`

	* Searches on every element, namely `x`, in `data`, such that
	  `predictor(x)` yields logically false, and figures the total
	  number of elements. The search operation is performed on the
	  same subrange that would be returned by `slice(data, from,
	  length)`.

	* Returns the number of occurrences as an integer, which is
	  always non-negative.

`std.array.exclude(data, target)`

	* Removes every element from `data` which compares equal to
	  `target` to create a new array. This function returns a new
	  array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude(data, from, target)`

	* Removes every element from `data` which both compares equal
	  to `target` and is within the same subrange that would be
	  returned by `slice(data, from)` to create a new array. This
	  function returns a new array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude(data, from, [length], target)`

	* Removes every element from `data` which both compares equal
	  to `target` and is within the same subrange that would be
	  returned by `slice(data, from, length)` to create a new array.
	  This function returns a new array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if(data, target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  `predictor(x)` yields logically false, to create a new array.
	  This function returns a new array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if(data, from, target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  both `predictor(x)` yields logically false and `x` is within
	  the subrange that would be returned by `slice(data, from)`,
	  to create a new array. This function returns a new array
	  without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if(data, from, [length], target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  both `predictor(x)` yields logically false and `x` is within
	  the subrange that would be returned by `slice(data, from,
	  length)`, to create a new array. This function returns a new
	  array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if_not(data, target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  `predictor(x)` yields logically true, to create a new array.
	  This function returns a new array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if_not(data, from, target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  both `predictor(x)` yields logically true and `x` is within
	  the subrange that would be returned by `slice(data, from)`,
	  to create a new array. This function returns a new array
	  without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.exclude_if_not(data, from, [length], target, predictor)`

	* Removes every element from `data`, namely `x`, such that
	  both `predictor(x)` yields logically true and `x` is within
	  the subrange that would be returned by `slice(data, from,
	  length)`, to create a new array. This function returns a new
	  array without modifying `data`.

	* Returns a new array with all occurrences removed.

`std.array.is_sorted(data, [comparator])`

	* Checks whether `data` is sorted. That is, there is no pair of
	  adjacent elements in `data` such that the first one is greater
	  than or unordered with the second one. Elements are compared
	  using `comparator`, which shall be a binary function that
	  returns a negative integer or real if the first argument is
	  less than the second one, a positive integer or real if the
	  first argument is greater than the second one, or `0` if the
	  arguments are equal; other values indicate that the arguments
	  are unordered. If no `comparator` is provided, the built-in
	  3-way comparison operator is used. An array that contains no
	  elements is considered to have been sorted.

	* Returns `true` if `data` is sorted or empty, or `false`
	  otherwise.

`std.array.binary_search(data, target, [comparator])`

	* Finds the first element in `data` that is equal to `target`.
	  The principle of user-defined `comparator`s is the same as the
	  `is_sorted()` function. As a consequence, the function call
	  `is_sorted(data, comparator)` shall yield `true` prior to this
	  call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer, if one
	  is found, or `null` otherwise.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.lower_bound(data, target, [comparator])`

	* Finds the first element in `data` that is greater than or equal
	  to `target` and precedes all elements that are less than
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer. This
	  function returns `countof(data)` if all elements are less than
	  `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.upper_bound(data, target, [comparator])`

	* Finds the first element in `data` that is greater than `target`
	  and precedes all elements that are less than or equal to
	  `target` if any. The principle of user-defined `comparator`s is
	  the same as the `is_sorted()` function. As a consequence, the
	  function call `is_sorted(data, comparator)` shall yield `true`
	  prior to this call, otherwise the effect is undefined.

	* Returns the subscript of such an element as an integer. This
	  function returns `countof(data)` if all elements are less than
	  or equal to `target`.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.equal_range(data, target, [comparator])`

	* Gets the range of elements equivalent to `target` in `data` as
	  a single function call. This function is equivalent to calling
	  `lower_bound(data, target, comparator)` and
	  `upper_bound(data, target, comparator)` respectively then
	  storing the start and length in an array.

	* Returns an array of two integers, the first of which specifies
	  the lower bound and the second of which specifies the number
	  of elements in the range.

	* Throws an exception if `data` has not been sorted properly. Be
	  advised that in this case there is no guarantee whether an
	  exception will be thrown or not.

`std.array.sort(data, [comparator])`

	* Sorts elements in `data` in ascending order. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`, and shall be stable.
	  This function returns a new array without modifying `data`.

	* Returns the sorted array.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.sortu(data, [comparator])`

	* Sorts elements in `data` in ascending order, then removes all
	  elements that have preceding equivalents. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. The algorithm shall finish in `O(n log n)` time where
	  `n` is the number of elements in `data`. This function returns
	  a new array without modifying `data`.

	* Returns the sorted array with no duplicate elements.

	* Throws an exception if any elements are unordered. Be advised
	  that in this case there is no guarantee whether an exception
	  will be thrown or not.

`std.array.max_of(data, [comparator])`

	* Finds the maximum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the maximum element, or `null` if `data` is
	  empty.

`std.array.min_of(data, [comparator])`

	* Finds the minimum element in `data`. The principle of
	  user-defined `comparator`s is the same as the `is_sorted()`
	  function. Elements that are unordered with the first element
	  are ignored silently.

	* Returns a copy of the minimum element, or `null` if `data` is
	  empty.

`std.array.reverse(data)`

	* Reverses an array. This function returns a new array without
	  modifying `data`.

	* Returns the reversed array.

`std.array.generate(generator, length)`

	* Calls `generator` repeatedly up to `length` times and returns
	  an array consisting of all values returned. `generator` shall
	  be a binary function. The first argument will be the number of
	  elements having been generated; the second argument is the
	  previous element generated, or `null` in the case of the first
	  element.

	* Returns an array containing all values generated.

`std.array.shuffle(data, [seed])`

	* Shuffles elements in `data` randomly. If `seed` is set to an
	  integer, the internal pseudo random number generator will be
	  initialized with it and will produce the same series of numbers
	  for a specific `seed` value. If it is absent, an unspecified
	  seed is generated when this function is called. This function
	  returns a new array without modifying `data`.

	* Returns the shuffled array.

`std.array.rotate(data, shift)`

	* Rotates elements in `data` by `shift`. That is, unless `data`
	  is empty, the element at subscript `x` is moved to subscript
	  `(x + shift) % countof(data)`. No element is added or removed.

	* Returns the rotated array. If `data` is empty, an empty array
	  is returned.

`std.array.copy_keys(source)`

	* Copies all keys from `source`, which shall be an object, to
	  create an array.

	* Returns an array of all keys in `source`.

`std.array.copy_values(source)`

	* Copies all values from `source`, which shall be an object, to
	  create an array.

	* Returns an array of all values in `source`.

### `std.numeric`

`std.numeric.integer_max`

	* Denotes the maximum value of an integer; that is, the value
	  `+0x7FFFFFFFFFFFFFFF`.

`std.numeric.integer_min`

	* Denotes the minimum value of an integer; that is, the value
	  `-0x8000000000000000`.

`std.numeric.real_max`

	* Denotes the maximum finite value of a real; that is, the
	  value `+0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_min`

	* Denotes the minimum finite value of a real; that is, the
	  value `-0x1FFFFFFFFFFFFFp+1023`.

`std.numeric.real_epsilon`

	* Denotes the minimum finite value of a real such that
	  `1 + real_epsilon > 1`; that is, `+0x1p-52`.

`std.numeric.size_max`

	* Denotes the maximum length of a string or array. This value is
	  implementation-dependent. Please be advised that there is no
	  guarantee that allocation of a string containing this number
	  of bytes will actually succeed or not.

`std.numeric.abs(value)`

	* Gets the absolute value of `value`, which may be an integer or
	  real. Negative integers are negated, which might cause an
	  exception to be thrown due to overflow. Sign bits of reals are
	  removed, which works on infinities and NaNs and does not
	  result in exceptions.

	* Return the absolute value.

	* Throws an exception if `value` is the integer `-0x1p63`.

`std.numeric.sign(value)`

	* Propagates the sign bit of the number `value`, which may be an
	  integer or real, to all bits of an integer. Be advised that
	  `-0.0` is distinct from `0.0` despite the equality.

	* Returns `-1` if `value` is negative, or `0` otherwise.

`std.numeric.is_finite(value)`

	* Checks whether `value` is a finite number. `value` may be an
	  integer or real. Be adviced that this functions returns `true`
	  for integers for consistency; integers do not support
	  infinities or NaNs.

	* Returns `true` if `value` is an integer or is a real that
	  is neither an infinity or a NaN, or `false` otherwise.

`std.numeric.is_infinity(value)`

	* Checks whether `value` is an infinity. `value` may be an
	  integer or real. Be adviced that this functions returns `false`
	  for integers for consistency; integers do not support
	  infinities.

	* Returns `true` if `value` is a real that denotes an infinity;
	  or `false` otherwise.

`std.numeric.is_nan(value)`

	* Checks whether `value` is a NaN. `value` may be an integer or
	  real. Be adviced that this functions returns `false` for
	  integers for consistency; integers do not support NaNs.

	* Returns `true` if `value` is a real denoting a NaN, or
	  `false` otherwise.

`std.numeric.clamp(value, lower, upper)`

	* Limits `value` between `lower` and `upper`.

	* Returns `lower` if `value < lower`, `upper` if `value > upper`,
	  or `value` otherwise, including when `value` is a NaN. The
	  returned value is an integer if all arguments are integers;
	  otherwise it is a real.

	* Throws an exception if `lower` is not less than or equal to
	  `upper`.

`std.numeric.round(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer; halfway values are rounded away from zero. If `value`
	  is an integer, it is returned intact.

	* Returns the rounded value.

`std.numeric.iround(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer; halfway values are rounded away from zero. If `value`
	  is an integer, it is returned intact. If `value` is a real, it
	  is converted to an integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.floor(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards negative infinity. If `value` is an integer, it
	  is returned intact.

	* Returns the rounded value.

`std.numeric.ifloor(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards negative infinity. If `value` is an integer, it
	  is returned intact. If `value` is a real, it is converted to an
	  integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.ceil(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards positive infinity. If `value` is an integer,
	  it is returned intact.

	* Returns the rounded value.

`std.numeric.iceil(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards positive infinity. If `value` is an integer, it
	  is returned intact. If `value` is a real, it is converted to an
	  integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.trunc(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards zero. If `value` is an integer, it is returned
	  intact.

	* Returns the rounded value.

`std.numeric.itrunc(value)`

	* Rounds `value`, which may be an integer or real, to the nearest
	  integer towards zero. If `value` is an integer, it is returned
	  intact. If `value` is a real, it is converted to an integer.

	* Returns the rounded value as an integer.

	* Throws an exception if the result cannot be represented as an
	  integer.

`std.numeric.random([limit])`

	* Generates a random real value whose sign agrees with `limit`
	  and whose absolute value is less than `limit`. If `limit` is
	  absent, `1` is assumed.

	* Returns a random real value.

	* Throws an exception if `limit` is zero or non-finite.

`std.numeric.sqrt(x)`

	* Calculates the square root of `x` which may be of either the
	  integer or the real type. The result is always a real.

	* Returns the square root of `x` as a real.

`std.numeric.fma(x, y, z)`

	* Performs fused multiply-add operation on `x`, `y` and `z`. This
	  functions calculates `x * y + z` without intermediate rounding
	  operations.

	* Returns the value of `x * y + z` as a real.

`std.numeric.remainder(x, y)`

	* Calculates the IEEE floating-point remainder of division of `x`
	  by `y`. The remainder is defined to be `x - q * y` where `q` is
	  the quotient of division of `x` by `y` rounding to nearest.

	* Returns the remainder as a real.

`std.numeric.frexp(x)`

	* Decomposes `x` into normalized fractional and exponent parts
	  such that `x = frac * pow(2,exp)` where `frac` and `exp` denote
	  the fraction and the exponent respectively and `frac` is always
	  within the range `[0.5,1.0)`. If `x` is non-finite, `exp` is
	  unspecified.

	* Returns an array having two elements, whose first element is
	  `frac` that is of type real and whose second element is `exp`
	  that is of type integer.

`std.numeric.ldexp(frac, exp)`

	* Composes `frac` and `exp` to make a real number `x`, as if by
	  multiplying `frac` with `pow(2,exp)`. `exp` shall be of type
	  integer. This function is the inverse of `frexp()`.

	* Returns the product as a real.

`std.numeric.addm(x, y)`

	* Adds `y` to `x` using modular arithmetic. `x` and `y` must be
	  of the integer type. The result is reduced to be congruent to
	  the sum of `x` and `y` modulo `0x1p64` in infinite precision.
	  This function will not cause overflow exceptions to be thrown.

	* Returns the reduced sum of `x` and `y`.

`std.numeric.subm(x, y)`

	* Subtracts `y` from `x` using modular arithmetic. `x` and `y`
	  must be of the integer type. The result is reduced to be
	  congruent to the difference of `x` and `y` modulo `0x1p64` in
	  infinite precision. This function will not cause overflow
	  exceptions to be thrown.

	* Returns the reduced difference of `x` and `y`.

`std.numeric.mulm(x, y)`

	* Multiplies `x` by `y` using modular arithmetic. `x` and `y`
	  must be of the integer type. The result is reduced to be
	  congruent to the product of `x` and `y` modulo `0x1p64` in
	  infinite precision. This function will not cause overflow
	  exceptions to be thrown.

	* Returns the reduced product of `x` and `y`.

`std.numeric.adds(x, y)`

	* Adds `y` to `x` using saturating arithmetic. `x` and `y` may be
	  integer or real values. The result is limited within the
	  range of representable values of its type, hence will not cause
	  overflow exceptions to be thrown. When either argument is of
	  type real which supports infinities, this function is
	  equivalent to the built-in addition operator.

	* Returns the saturated sum of `x` and `y`.

`std.numeric.subs(x, y)`

	* Subtracts `y` from `x` using saturating arithmetic. `x` and `y`
	  may be integer or real values. The result is limited within the
	  range of representable values of its type, hence will not cause
	  overflow exceptions to be thrown. When either argument is of
	  type real which supports infinities, this function is
	  equivalent to the built-in subtraction operator.

	* Returns the saturated difference of `x` and `y`.

`std.numeric.muls(x, y)`

	* Multiplies `x` by `y` using saturating arithmetic. `x` and `y`
	  may be integer or real values. The result is limited within the
	  range of representable values of its type, hence will not cause
	  overflow exceptions to be thrown. When either argument is of
	  type real which supports infinities, this function is
	  equivalent to the built-in multiplication operator.

	* Returns the saturated product of `x` and `y`.

`std.numeric.lzcnt(x)`

	* Counts the number of leading zero bits in `x`, which shall be
	  of type integer.

	* Returns the bit count as an integer. If `x` is zero, `64` is
	  returned.

`std.numeric.tzcnt(x)`

	* Counts the number of trailing zero bits in `x`, which shall be
	  of type integer.

	* Returns the bit count as an integer. If `x` is zero, `64` is
	  returned.

`std.numeric.popcnt(x)`

	* Counts the number of one bits in `x`, which shall be of type
	  integer.

	* Returns the bit count as an integer.

`std.numeric.rotl(m, x, n)`

	* Rotates the rightmost `m` bits of `x` to the left by `n`; all
	  arguments must be of type integer. This has the effect of
	  shifting `x` by `n` to the left then filling the vacuum in the
	  right with the last `n` bits that have just been shifted past
	  the left boundary. `n` is modulo `m` so rotating by a negative
	  count to the left has the same effect as rotating by its
	  absolute value to the right. All other bits are zeroed. If `m`
	  is zero, zero is returned.

	* Returns the rotated value as an integer.

	* Throws an exception if `m` is negative or greater than `64`.

`std.numeric.rotr(m, x, n)`

	* Rotates the rightmost `m` bits of `x` to the right by `n`; all
	  arguments must be of type integer. This has the effect of
	  shifting `x` by `n` to the right then filling the vacuum in the
	  left with the last `n` bits that have just been shifted past
	  the right boundary. `n` is modulo `m` so rotating by a negative
	  count to the right has the same effect as rotating by its
	  absolute value to the left. All other bits are zeroed. If `m`
	  is zero, zero is returned.

	* Returns the rotated value as an integer.

	* Throws an exception if `m` is negative or greater than `64`.

`std.numeric.format(value, [base], [ebase])`

	* Converts an integer or real number to a string in `base`. This
	  function writes as many digits as possible to ensure precision.
	  No plus sign precedes the significant figures. If `base` is
	  absent, `10` is assumed. If `ebase` is specified, an exponent
	  is appended to the significand as follows: If `value` is of
	  type integer, the significand is kept as short as possible;
	  otherwise (when `value` is of type real), it is written in
	  scientific notation. In both cases, the exponent comprises at
	  least two digits with an explicit sign. If `ebase` is absent,
	  no exponent appears. The result is exact as long as `base` is a
	  power of two.

	* Returns a string converted from `value`.

	* Throws an exception if `base` is neither `2` nor `10` nor `16`,
	  or if `ebase` is neither `2` nor `10`, or if `base` is not `10`
	  but `ebase` is `10`.

`std.numeric.parse_integer(text)`

	* Parses `text` for an integer. `text` shall be a string. All
	  leading and trailing blank characters are stripped from `text`.
	  If it becomes empty, this function fails; otherwise, it shall
	  match one of the following extended regular expressions:

	  * Binary (base-2):
	    `[+-]?0[bB][01]+`
	  * Hexadecimal (base-16):
	    `[+-]?0[xX][0-9a-fA-F]+`
	  * Decimal (base-10):
	    `[+-]?[0-9]+`

	  If the string does not match any of the above, this function
	  fails. If the result is outside the range of representable
	  values of type integer, this function fails.

	* Returns the integer value converted from `text`.

	* Throws an exception on failure.

`std.numeric.parse_real(text, [saturating])`

	* Parses `text` for a real number. `text` shall be a string. All
	  leading and trailing blank characters are stripped from `text`.
	  If it becomes empty, this function fails; otherwise, it shall
	  match any of the following extended regular expressions:

	  * Infinities:
	    `[+-]?infinity`
	  * NaNs:
	    `[+-]?nan`
	  * Binary (base-2):
	    `[+-]?0[bB][01]+(\.[01]+)?([epEP][-+]?[0-9]+)?`
	  * Hexadecimal (base-16):
	    `[+-]?0x[0-9a-fA-F]+(\.[0-9a-fA-F]+)?([epEP][-+]?[0-9]+)?`
	  * Decimal (base-10):
	    `[+-]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?`

	  If the string does not match any of the above, this function
	  fails. If the absolute value of the result is too small to fit
	  in a real, a signed zero is returned. When the absolute value
	  is too large, if `saturating` is set to `true`, a signed
	  infinity is returned; otherwise this function fails.

	* Returns the real value converted from `text`.

	* Throws an exception on failure.

### `std.math`

`std.math.e`

	* Denotes the base of the natural logarithm; that is,
	  `2.7182818284590452353602874713526624977572470937000`.

`std.math.pi`

	* Denotes the ratio of a circle's circumference to its diameter;
	  that is, `3.1415926535897932384626433832795028841971693993751`.

`std.math.lb10`

	* Denotes the binary logarithm of the integer ten; that is,
	  `3.3219280948873623478703194294893901758648313930246`.

`std.math.exp(y, [base])`

	* Calculates `base` raised to the power `y`. If `base` is absent,
	  `e` is assumed. This function is equivalent to `pow(base, y)`.

	* Returns the power as a real.

`std.math.expm1(y)`

	* Calculates `exp(y) - 1` without losing precision when `y` is
	  close to zero.

	* Returns the result as a real.

`std.math.pow(x, y)`

	* Calculates `x` raised to the power `y`. According to C99, when
	  `x` is `1` or `y` is `0`, the result is always `1`, even when
	  the other argument is an infinity or NaN.

	* Returns the power as a real.

`std.math.log(x, [base])`

	* Calculates the logarithm of `x` to `base`. If `base` is absent,
	  `e` is assumed.

	* Returns the logarithm as a real.

`std.math.log1p(x)`

	* Calculates `log(1 + x)` without losing precision when `x` is
	  close to zero.

	* Returns the result as a real.

`std.math.sin(x)`

	* Calculates the sine of `x` in radians.

	* Returns the result as a real.

`std.math.cos(x)`

	* Calculates the cosine of `x` in radians.

	* Returns the result as a real.

`std.math.sincos(x)`

	* Calculates the sine and cosine of `x` in radians.

	* Returns an array of two reals. The first element is the sine
	  and the other is the cosine.

`std.math.tan(x)`

	* Calculates the tangent of `x` in radians.

	* Returns the result as a real.

`std.math.asin(x)`

	* Calculates the inverse sine of `x` in radians.

	* Returns the result as a real.

`std.math.acos(x)`

	* Calculates the inverse cosine of `x` in radians.

	* Returns the result as a real.

`std.math.atan(x)`

	* Calculates the inverse tangent of `x` in radians.

	* Returns the result as a real.

`std.math.atan2(y, x)`

	* Calculates the angle of the vector `<x,y>` in radians.

	* Returns the result as a real.

`std.math.hypot(...)`

	* Calculates the length of the n-dimension vector defined by all
	  arguments. If no argument is provided, this function returns
	  zero. If any argument is an infinity, this function returns a
	  positive infinity; otherwise, if any argument is a NaN, this
	  function returns a NaN.

	* Returns the length as a real.

`std.math.sinh(x)`

	* Calculates the hyperbolic sine of `x`.

	* Returns the result as a real.

`std.math.cosh(x)`

	* Calculates the hyperbolic cosine of `x`.

	* Returns the result as a real.

`std.math.tanh(x)`

	* Calculates the hyperbolic tangent of `x`.

	* Returns the result as a real.

`std.math.asinh(x)`

	* Calculates the inverse hyperbolic sine of `x`.

	* Returns the result as a real.

`std.math.acosh(x)`

	* Calculates the inverse hyperbolic cosine of `x`.

	* Returns the result as a real.

`std.math.atanh(x)`

	* Calculates the inverse hyperbolic tangent of `x`.

	* Returns the result as a real.

`std.math.erf(x)`

	* Calculates the error function of `x`.

	* Returns the result as a real.

`std.math.cerf(x)`

	* Calculates the complementary error function of `x`.

	* Returns the result as a real.

`std.math.gamma(x)`

	* Calculates the Gamma function of `x`.

	* Returns the result as a real.

`std.math.lgamma(x)`

	* Calculates the natural logarithm of the absolute value of the
	  Gamma function of `x`.

	* Returns the result as a real.

### `std.filesystem`

`std.filesystem.get_working_directory()`

	* Gets the absolute path of the current working directory.

	* Returns a string containing the path to the current working
	  directory.

`std.filesystem.get_real_path(path)`

	* Converts `path` to an absolute one. The result is a canonical
	  path that contains no symbolic links. The path must be valid
	  and accessible.

	* Returns a string denoting the absolute path.

	* Throws an exception if `path` is invalid or inaccessible.

`std.filesystem.get_information(path)`

	* Retrieves information of the file or directory designated by
	  `path`.

	* Returns an object consisting of the following members (names
	  that start with `b_` are boolean values; names that start with
	  `i_` are IDs as integers; names that start with `n_` are
	  plain integers; names that start with `t_` are timestamps in
	  UTC as integers):

	  * `i_dev`   unique device id on this machine.
	  * `i_file`  unique file id on this device.
	  * `n_ref`   number of hard links to this file.
	  * `b_dir`   whether this is a directory.
	  * `b_sym`   whether this is a symbolic link.
	  * `n_size`  number of bytes this file contains.
	  * `n_ocup`  number of bytes this file occupies.
	  * `t_accs`  timestamp of last access.
	  * `t_mod`   timestamp of last modification.

	  On failure, `null` is returned.

`std.filesystem.move_from(path_new, path_old)`

	* Moves (renames) the file or directory at `path_old` to
	  `path_new`.

	* Throws an exception on failure.

`std.filesystem.remove_recursive(path)`

	* Removes the file or directory at `path`. If `path` designates a
	  directory, all of its contents are removed recursively.

	* Returns the number of files and directories that have been
	  successfully removed in total. If `path` does not reference an
	  existent file or directory, `0` is returned.

	* Throws an exception if the file or directory at `path` cannot
	  be removed.

`std.filesystem.directory_list(path)`

	* Lists the contents of the directory at `path`.

	* Returns an object containing all entries of the directory at
	  `path`, excluding the special subdirectories '.' and '..'. For
	  each element, its key specifies the filename and the value is
	  an object consisting of the following members (names that
	  start with `b_` are boolean values; names that start with `i_`
	  are IDs as integers):

	  * `b_dir`   whether this is a directory.
	  * `b_sym`   whether this is a symbolic link.

	* Throws an exception if `path` does not designate a directory,
	  or some other errors occur.

`std.filesystem.directory_create(path)`

	* Creates a directory at `path`. Its parent directory must exist
	  and must be accessible. This function does not fail if either a
	  directory or a symbolic link to a directory already exists on
	  `path`.

	* Returns `1` if a new directory has been created, or `0` if a
	  directory already exists.

	* Throws an exception if `path` designates a non-directory, or
	  some other errors occur.

`std.filesystem.directory_remove(path)`

	* Removes the directory at `path`. The directory must be empty.
	  This function fails if `path` does not designate a directory.

	* Returns `1` if a directory has been removed successfully, or
	  `0` if no such directory exists.

	* Throws an exception if `path` designates a non-directory, or
	  some other errors occur.

`std.filesystem.file_read(path, [offset], [limit])`

	* Reads the file at `path` in binary mode. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns the bytes that have been read as a string.

	* Throws an exception if `offset` is negative, or a read error
	  occurs.

`std.filesystem.file_stream(path, callback, [offset], [limit])`

	* Reads the file at `path` in binary mode and invokes `callback`
	  with the data read repeatedly. `callback` shall be a binary
	  function whose first argument is the absolute offset of the
	  data block that has been read, and whose second argument is the
	  bytes read and stored in a string. Data may be transferred in
	  multiple blocks of variable sizes; the caller shall make no
	  assumption about the number of times that `callback` will be
	  called or the size of each individual block. The read operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. If
	  `limit` is specified, no more than this number of bytes will be
	  read.

	* Returns the number of bytes that have been read and processed
	  as an integer.

	* Throws an exception if `offset` is negative, or a read error
	  occurs.

`std.filesystem.file_write(path, data, [offset])`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the byte offset that is denoted by `offset` if it
	  is specified, or from the beginning of the file otherwise. The
	  file is truncated to this length before the write operation;
	  any existent contents after the write point are discarded. This
	  function fails if the data can only be written partially.

	* Throws an exception if `offset` is negative, or a write error
	  occurs.

`std.filesystem.file_append(path, data, [exclusive])`

	* Writes the file at `path` in binary mode. The write operation
	  starts from the end of the file; existent contents of the file
	  are left intact. If `exclusive` is `true` and a file exists on
	  `path`, this function fails. This function also fails if the
	  data can only be written partially.

	* Throws an exception if `offset` is negative, or a write error
	  occurs.

`std.filesystem.file_copy_from(path_new, path_old)`

	* Copies the file `path_old` to `path_new`. If `path_old` is a
	  symbolic link, it is the target that will be copied, rather
	  than the symbolic link itself. This function fails if
	  `path_old` designates a directory.

	* Throws an exception on failure.

`std.filesystem.file_remove(path)`

	* Removes the file at `path`. This function fails if `path`
	  designates a directory.

	* Returns `1` if a file has been removed successfully, or `0` if
	  no such file exists.

	* Throws an exception if `path` designates a directory, or some
	  other errors occur.

### `std.checksum`

`std.checksum.crc32_new()`

	* Creates a CRC-32 hasher according to ISO/IEC 3309. The divisor
	  is `0x04C11DB7` (or `0xEDB88320` in reverse form).

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as an integer (whose
	  high-order 32 bits are always zeroes), then resets the hasher,
	  making it suitable for further data as if it had just been
	  created.

`std.checksum.crc32(data)`

	* Calculates the CRC-32 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.crc32 = func(data) {
	    var h = this.crc32_new();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the CRC-32 checksum as an integer. The high-order 32
	  bits are always zeroes.

`std.checksum.crc32_file(path)`

	* Calculates the CRC-32 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.crc32_file = func(path) {
	    var h = this.crc32_new();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the CRC-32 checksum as an integer. The high-order 32
	  bits are always zeroes.

	* Throws an exception if a read error occurs.

`std.checksum.fnv1a32_new()`

	* Creates a 32-bit Fowler-Noll-Vo (a.k.a. FNV) hasher of the
	  32-bit FNV-1a variant. The FNV prime is `16777619` and the FNV
	  offset basis is `2166136261`.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as an integer (whose
	  high-order 32 bits are always zeroes), then resets the hasher,
	  making it suitable for further data as if it had just been
	  created.

`std.checksum.fnv1a32(data)`

	* Calculates the 32-bit FNV-1a checksum of `data` which must be
	  a byte string, as if this function was defined as

	  ```
	  std.checksum.fnv1a32 = func(data) {
	    var h = this.fnv1a32_new();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the 32-bit FNV-1a checksum as an integer. The
	  high-order 32 bits are always zeroes.

`std.checksum.fnv1a32_file(path)`

	* Calculates the 32-bit FNV-1a checksum of the file denoted by
	  `path`, as if this function was defined as

	  ```
	  std.checksum.fnv1a32_file = func(path) {
	    var h = this.fnv1a32_new();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the 32-bit FNV-1a checksum as an integer. The
	  high-order 32 bits are always zeroes.

	* Throws an exception if a read error occurs.

`std.checksum.md5_new()`

	* Creates an MD5 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 32
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.

`std.checksum.md5(data)`

	* Calculates the MD5 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.md5 = func(data) {
	    var h = this.md5_new();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the MD5 checksum as a string of 32 hexadecimal digits
	  in uppercase.

`std.checksum.md5_file(path)`

	* Calculates the MD5 checksum of the file denoted by `path`, as
	  if this function was defined as

	  ```
	  std.checksum.md5_file = func(path) {
	    var h = this.md5_new();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the MD5 checksum as a string of 32 hexadecimal digits
	  in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.sha1_new()`

	* Creates an SHA-1 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 40
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.

`std.checksum.sha1(data)`

	* Calculates the SHA-1 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha1 = func(data) {
	    var h = this.sha1_new();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-1 checksum as a string of 40 hexadecimal
	  digits in uppercase.

`std.checksum.sha1_file(path)`

	* Calculates the SHA-1 checksum of the file denoted by `path`, as
	  if this function was defined as

	  ```
	  std.checksum.sha1_file = func(path) {
	    var h = this.sha1_new();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-1 checksum as a string of 40 hexadecimal digits
	  in uppercase.

	* Throws an exception if a read error occurs.

`std.checksum.sha256_new()`

	* Creates an SHA-256 hasher.

	* Returns the hasher as an object consisting of the following
	  members:

	  * `update(data)`
	  * `finish()`

	  The function `update()` is used to put data into the hasher,
	  which shall be a byte string. After all data have been put, the
	  function `finish()` extracts the checksum as a string of 64
	  hexadecimal digits in uppercase, then resets the hasher, making
	  it suitable for further data as if it had just been created.

`std.checksum.sha256(data)`

	* Calculates the SHA-256 checksum of `data` which must be of type
	  string, as if this function was defined as

	  ```
	  std.checksum.sha256 = func(data) {
	    var h = this.sha256_new();
	    h.update(data);
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-256 checksum as a string of 64 hexadecimal
	  digits in uppercase.

`std.checksum.sha256_file(path)`

	* Calculates the SHA-256 checksum of the file denoted by `path`,
	  as if this function was defined as

	  ```
	  std.checksum.sha256_file = func(path) {
	    var h = this.sha256_new();
	    this.file_stream(path, func(off, data) = h.update(data));
	    return h.finish();
	  };
	  ```

	  This function is expected to be both more efficient and easier
	  to use.

	* Returns the SHA-256 checksum as a string of 64 hexadecimal
	  digits in uppercase.

	* Throws an exception if a read error occurs.

### `std.json`

`std.json.format(value, [indent])`

	* Converts a value to a string in the JSON format, according to
	  IETF RFC 7159. This function generates text that conforms to
	  JSON strictly; values whose types cannot be represented in JSON
	  are discarded if they are found in an object and censored to
	  `null` otherwise. If `indent` is set to a string, it is used as
	  each level of indention following a line break, unless it is
	  empty, in which case no line break is inserted. If `indent` is
	  set to an integer, it is clamped between `0` and `10`
	  inclusively and this function behaves as if a string consisting
	  of this number of spaces was set. Its default value is an empty
	  string.

	* Returns the formatted text as a string.

`std.json.format5(value, [indent])`

	* Converts a value to a string in the JSON5 format. In addition
	  to IETF RFC 7159, a few extensions in ECMAScript 5.1 have been
	  introduced to make the syntax more human-readable. Infinities
	  and NaNs are preserved. Object keys that are valid identifiers
	  are not quoted. Trailing commas of array and object members are
	  appended if `indent` is neither null nor zero nor an empty
	  string. This function is otherwise identical to `format()`.

	* Returns the formatted text as a string.

`std.json.parse(text)`

	* Parses a string containing data encoded in the JSON format and
	  converts it to a value. This function reuses the tokenizer of
	  Asteria and allows quite a few extensions, some of which are
	  also supported by JSON5:

	  * Single-line and multiple-line comments are allowed.
	  * Binary and hexadecimal numbers are allowed.
	  * Numbers can have binary exponents.
	  * Infinities and NaNs are allowed.
	  * Numbers can start with plus signs.
	  * Strings and object keys may be single-quoted.
	  * Escape sequences (including UTF-32) are allowed in strings.
	  * Element lists of arrays and objects may end in commas.
	  * Object keys may be unquoted if they are valid identifiers.

	  Be advised that numbers are always parsed as reals.

	* Returns the parsed value.

	* Throws an exception if the string is invalid.

`std.json.parse_file(path)`

	* Parses the contents of the file denoted by `path` as a JSON
	  string. This function behaves identical to `parse()` otherwise.

	* Returns the parsed value.

	* Throws an exception if a read error occurs, or if the string is
	  invalid.

### `std.io`

`std.io.getc()`

	* Reads a UTF code point from standard input.

	* Returns the code point that has been read as an integer. If the
	  end of input is encountered, `null` is returned.

	* Throws an exception if standard input is binary-oriented, or if
	  a read error occurs.

`std.io.getln()`

	* Reads a UTF-8 string from standard input, which is terminated
	  by either a LF character or the end of input. The terminating
	  LF, if any, is not included in the returned string.

	* Returns the line that has been read as a string. If the end of
	  input is encountered, `null` is returned.

	* Throws an exception if standard input is binary-oriented, or if
	  a read error occurs, or if source data cannot be converted to a
	  valid UTF code point sequence.

`std.io.putc(value)`

	* Writes a UTF-8 string to standard output. `value` may be either
	  an integer representing a UTF code point or a UTF-8 string.

	* Returns the number of UTF code points that have been written.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.putln(text)`

	* Writes a UTF-8 string to standard output, followed by a LF,
	  which may flush the stream automatically. `text` shall be a
	  UTF-8 string.

	* Returns the number of UTF code points that have been written,
	  including the terminating LF.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.putf(templ, ...)`

	* Compose a string in the same way as `std.string.format()`, but
	  instead of returning it, write it to standard output.

	* Returns the number of UTF code points that have been written.

	* Throws an exception if standard output is binary-oriented, or
	  if source data cannot be converted to a valid UTF code point
	  sequence, or if a write error occurs.

`std.io.read([limit])`

	* Reads a series of bytes from standard input. If `limit` is set,
	  no more than this number of bytes will be read.

	* Returns the bytes that have been read as a string. If the end
	  of input is encountered, `null` is returned.

	* Throws an exception if standard input is text-oriented, or if
	  a read error occurs, or if source data cannot be converted to a
	  valid UTF code point sequence.

`std.io.write(data)`

	* Writes a series of bytes to standard output. `data` shall be a
	  byte string.

	* Returns the number of bytes that have been written.

	* Throws an exception if standard output is text-oriented, or if
	  a write error occurs.

`std.io.flush()`

	* Forces buffered data on standard output to be delivered to its
	  underlying device. This function may be called regardless of
	  the orientation of standard output.

	* Throws an exception if a write error occurs.
