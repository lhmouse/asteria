// This file is part of Asteria.
// Copyleft 2018 - 2019, LH_Mouse. All wrongs reserved.

#ifndef ASTERIA_RUNTIME_REFERENCE_STACK_HPP_
#define ASTERIA_RUNTIME_REFERENCE_STACK_HPP_

#include "../fwd.hpp"
#include "reference.hpp"

namespace Asteria {

class Reference_Stack
  {
  private:
    Cow_Vector<Reference> m_stor;
    Reference *m_btop;  // This points to the next element of the top.

  public:
    Reference_Stack() noexcept
      : m_stor(), m_btop(this->m_stor.mut_data())
      {
      }
    ~Reference_Stack();

    Reference_Stack(const Reference_Stack &)
      = delete;
    Reference_Stack & operator=(const Reference_Stack &)
      = delete;

  public:
    bool empty() const noexcept
      {
        return this->m_btop == this->m_stor.data();
      }
    std::size_t size() const noexcept
      {
        return static_cast<std::size_t>(this->m_btop - this->m_stor.data());
      }
    void clear() noexcept
      {
        this->m_btop = this->m_stor.mut_data();
      }

    const Reference & top() const noexcept
      {
        auto btop = this->m_btop;
        ROCKET_ASSERT(btop != this->m_stor.data());
        return btop[-1];
      }
    Reference & mut_top() noexcept
      {
        auto btop = this->m_btop;
        ROCKET_ASSERT(btop != this->m_stor.data());
        return btop[-1];
      }
    template<typename ParamT> Reference & push(ParamT &&param)
      {
        auto btop = this->m_btop;
        if(ROCKET_EXPECT(btop != this->m_stor.data() + this->m_stor.size())) {
          // Overwrite an existent element.
          *btop = std::forward<ParamT>(param);
        } else {
          // Construct a new element.
          btop = std::addressof(this->m_stor.emplace_back(std::forward<ParamT>(param)));
        }
        // Set up the past-the-top pointer.
        ++btop;
        this->m_btop = btop;
        return btop[-1];
      }
    void pop() noexcept
      {
        auto btop = this->m_btop;
        ROCKET_ASSERT(btop != this->m_stor.data());
        // Set up the past-the-top pointer.
        --btop;
        this->m_btop = btop;
      }
    void pop_prev() noexcept
      {
        auto btop = this->m_btop;
        ROCKET_ASSERT(btop - this->m_stor.data() >= 2);
        // Overwrite the previous element with the top.
        btop[-2] = std::move(btop[-1]);
        // Set up the past-the-top pointer.
        --btop;
        this->m_btop = btop;
      }
  };

}

#endif
